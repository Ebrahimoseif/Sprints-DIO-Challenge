
DIO_Challenge.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000077c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  0000077c  00000810  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000006  00800062  00800062  00000812  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000812  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000844  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000260  00000000  00000000  00000880  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002584  00000000  00000000  00000ae0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d26  00000000  00000000  00003064  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000eb5  00000000  00000000  00003d8a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000528  00000000  00000000  00004c40  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d01  00000000  00000000  00005168  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000148c  00000000  00000000  00005e69  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000210  00000000  00000000  000072f5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 d2 02 	jmp	0x5a4	; 0x5a4 <__vector_3>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 81 03 	jmp	0x702	; 0x702 <__vector_10>
  2c:	0c 94 19 03 	jmp	0x632	; 0x632 <__vector_11>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ec e7       	ldi	r30, 0x7C	; 124
  68:	f7 e0       	ldi	r31, 0x07	; 7
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a2 36       	cpi	r26, 0x62	; 98
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a2 e6       	ldi	r26, 0x62	; 98
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a8 36       	cpi	r26, 0x68	; 104
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 22 02 	call	0x444	; 0x444 <main>
  8a:	0c 94 bc 03 	jmp	0x778	; 0x778 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <gpioPortDirection>:
				break;
			case 2:
				PORTC_DATA ^= u8_pins;
				break;
			case 3:
				PORTD_DATA ^= u8_pins;
  92:	81 30       	cpi	r24, 0x01	; 1
  94:	41 f0       	breq	.+16     	; 0xa6 <gpioPortDirection+0x14>
  96:	28 f0       	brcs	.+10     	; 0xa2 <gpioPortDirection+0x10>
  98:	82 30       	cpi	r24, 0x02	; 2
  9a:	39 f0       	breq	.+14     	; 0xaa <gpioPortDirection+0x18>
  9c:	83 30       	cpi	r24, 0x03	; 3
  9e:	39 f0       	breq	.+14     	; 0xae <gpioPortDirection+0x1c>
  a0:	08 95       	ret
  a2:	6a bb       	out	0x1a, r22	; 26
  a4:	08 95       	ret
  a6:	67 bb       	out	0x17, r22	; 23
  a8:	08 95       	ret
  aa:	64 bb       	out	0x14, r22	; 20
  ac:	08 95       	ret
  ae:	61 bb       	out	0x11, r22	; 17
  b0:	08 95       	ret

000000b2 <gpioPortWrite>:
  b2:	81 30       	cpi	r24, 0x01	; 1
  b4:	41 f0       	breq	.+16     	; 0xc6 <gpioPortWrite+0x14>
  b6:	28 f0       	brcs	.+10     	; 0xc2 <gpioPortWrite+0x10>
  b8:	82 30       	cpi	r24, 0x02	; 2
  ba:	39 f0       	breq	.+14     	; 0xca <gpioPortWrite+0x18>
  bc:	83 30       	cpi	r24, 0x03	; 3
  be:	39 f0       	breq	.+14     	; 0xce <gpioPortWrite+0x1c>
  c0:	08 95       	ret
  c2:	6b bb       	out	0x1b, r22	; 27
  c4:	08 95       	ret
  c6:	68 bb       	out	0x18, r22	; 24
  c8:	08 95       	ret
  ca:	65 bb       	out	0x15, r22	; 21
  cc:	08 95       	ret
  ce:	62 bb       	out	0x12, r22	; 18
  d0:	08 95       	ret

000000d2 <gpioPortRead>:
  d2:	81 30       	cpi	r24, 0x01	; 1
  d4:	41 f0       	breq	.+16     	; 0xe6 <gpioPortRead+0x14>
  d6:	28 f0       	brcs	.+10     	; 0xe2 <gpioPortRead+0x10>
  d8:	82 30       	cpi	r24, 0x02	; 2
  da:	39 f0       	breq	.+14     	; 0xea <gpioPortRead+0x18>
  dc:	83 30       	cpi	r24, 0x03	; 3
  de:	39 f0       	breq	.+14     	; 0xee <gpioPortRead+0x1c>
  e0:	08 c0       	rjmp	.+16     	; 0xf2 <gpioPortRead+0x20>
  e2:	89 b3       	in	r24, 0x19	; 25
  e4:	08 95       	ret
  e6:	86 b3       	in	r24, 0x16	; 22
  e8:	08 95       	ret
  ea:	83 b3       	in	r24, 0x13	; 19
  ec:	08 95       	ret
  ee:	80 b3       	in	r24, 0x10	; 16
  f0:	08 95       	ret
  f2:	80 e0       	ldi	r24, 0x00	; 0
  f4:	08 95       	ret

000000f6 <gpioPinDirection>:
  f6:	81 30       	cpi	r24, 0x01	; 1
  f8:	89 f0       	breq	.+34     	; 0x11c <gpioPinDirection+0x26>
  fa:	28 f0       	brcs	.+10     	; 0x106 <gpioPinDirection+0x10>
  fc:	82 30       	cpi	r24, 0x02	; 2
  fe:	c9 f0       	breq	.+50     	; 0x132 <gpioPinDirection+0x3c>
 100:	83 30       	cpi	r24, 0x03	; 3
 102:	11 f1       	breq	.+68     	; 0x148 <gpioPinDirection+0x52>
 104:	08 95       	ret
 106:	41 11       	cpse	r20, r1
 108:	05 c0       	rjmp	.+10     	; 0x114 <gpioPinDirection+0x1e>
 10a:	8a b3       	in	r24, 0x1a	; 26
 10c:	60 95       	com	r22
 10e:	68 23       	and	r22, r24
 110:	6a bb       	out	0x1a, r22	; 26
 112:	08 95       	ret
 114:	8a b3       	in	r24, 0x1a	; 26
 116:	68 2b       	or	r22, r24
 118:	6a bb       	out	0x1a, r22	; 26
 11a:	08 95       	ret
 11c:	41 11       	cpse	r20, r1
 11e:	05 c0       	rjmp	.+10     	; 0x12a <gpioPinDirection+0x34>
 120:	87 b3       	in	r24, 0x17	; 23
 122:	60 95       	com	r22
 124:	68 23       	and	r22, r24
 126:	67 bb       	out	0x17, r22	; 23
 128:	08 95       	ret
 12a:	87 b3       	in	r24, 0x17	; 23
 12c:	68 2b       	or	r22, r24
 12e:	67 bb       	out	0x17, r22	; 23
 130:	08 95       	ret
 132:	41 11       	cpse	r20, r1
 134:	05 c0       	rjmp	.+10     	; 0x140 <gpioPinDirection+0x4a>
 136:	84 b3       	in	r24, 0x14	; 20
 138:	60 95       	com	r22
 13a:	68 23       	and	r22, r24
 13c:	64 bb       	out	0x14, r22	; 20
 13e:	08 95       	ret
 140:	84 b3       	in	r24, 0x14	; 20
 142:	68 2b       	or	r22, r24
 144:	64 bb       	out	0x14, r22	; 20
 146:	08 95       	ret
 148:	41 11       	cpse	r20, r1
 14a:	05 c0       	rjmp	.+10     	; 0x156 <gpioPinDirection+0x60>
 14c:	81 b3       	in	r24, 0x11	; 17
 14e:	60 95       	com	r22
 150:	68 23       	and	r22, r24
 152:	61 bb       	out	0x11, r22	; 17
 154:	08 95       	ret
 156:	81 b3       	in	r24, 0x11	; 17
 158:	68 2b       	or	r22, r24
 15a:	61 bb       	out	0x11, r22	; 17
 15c:	08 95       	ret

0000015e <gpioPinWrite>:
 15e:	81 30       	cpi	r24, 0x01	; 1
 160:	89 f0       	breq	.+34     	; 0x184 <gpioPinWrite+0x26>
 162:	28 f0       	brcs	.+10     	; 0x16e <gpioPinWrite+0x10>
 164:	82 30       	cpi	r24, 0x02	; 2
 166:	c9 f0       	breq	.+50     	; 0x19a <gpioPinWrite+0x3c>
 168:	83 30       	cpi	r24, 0x03	; 3
 16a:	11 f1       	breq	.+68     	; 0x1b0 <gpioPinWrite+0x52>
 16c:	08 95       	ret
 16e:	8b b3       	in	r24, 0x1b	; 27
 170:	96 2f       	mov	r25, r22
 172:	90 95       	com	r25
 174:	89 23       	and	r24, r25
 176:	8b bb       	out	0x1b, r24	; 27
 178:	44 23       	and	r20, r20
 17a:	21 f1       	breq	.+72     	; 0x1c4 <gpioPinWrite+0x66>
 17c:	8b b3       	in	r24, 0x1b	; 27
 17e:	68 2b       	or	r22, r24
 180:	6b bb       	out	0x1b, r22	; 27
 182:	08 95       	ret
 184:	88 b3       	in	r24, 0x18	; 24
 186:	96 2f       	mov	r25, r22
 188:	90 95       	com	r25
 18a:	89 23       	and	r24, r25
 18c:	88 bb       	out	0x18, r24	; 24
 18e:	44 23       	and	r20, r20
 190:	c9 f0       	breq	.+50     	; 0x1c4 <gpioPinWrite+0x66>
 192:	88 b3       	in	r24, 0x18	; 24
 194:	68 2b       	or	r22, r24
 196:	68 bb       	out	0x18, r22	; 24
 198:	08 95       	ret
 19a:	85 b3       	in	r24, 0x15	; 21
 19c:	96 2f       	mov	r25, r22
 19e:	90 95       	com	r25
 1a0:	89 23       	and	r24, r25
 1a2:	85 bb       	out	0x15, r24	; 21
 1a4:	44 23       	and	r20, r20
 1a6:	71 f0       	breq	.+28     	; 0x1c4 <gpioPinWrite+0x66>
 1a8:	85 b3       	in	r24, 0x15	; 21
 1aa:	68 2b       	or	r22, r24
 1ac:	65 bb       	out	0x15, r22	; 21
 1ae:	08 95       	ret
 1b0:	82 b3       	in	r24, 0x12	; 18
 1b2:	96 2f       	mov	r25, r22
 1b4:	90 95       	com	r25
 1b6:	89 23       	and	r24, r25
 1b8:	82 bb       	out	0x12, r24	; 18
 1ba:	44 23       	and	r20, r20
 1bc:	19 f0       	breq	.+6      	; 0x1c4 <gpioPinWrite+0x66>
 1be:	82 b3       	in	r24, 0x12	; 18
 1c0:	68 2b       	or	r22, r24
 1c2:	62 bb       	out	0x12, r22	; 18
 1c4:	08 95       	ret

000001c6 <gpioPinRead>:
 */
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin){
	
			uint8_t	u8_value = 0;
			
			switch(u8_port){
 1c6:	81 30       	cpi	r24, 0x01	; 1
 1c8:	49 f0       	breq	.+18     	; 0x1dc <gpioPinRead+0x16>
 1ca:	28 f0       	brcs	.+10     	; 0x1d6 <gpioPinRead+0x10>
 1cc:	82 30       	cpi	r24, 0x02	; 2
 1ce:	49 f0       	breq	.+18     	; 0x1e2 <gpioPinRead+0x1c>
 1d0:	83 30       	cpi	r24, 0x03	; 3
 1d2:	51 f0       	breq	.+20     	; 0x1e8 <gpioPinRead+0x22>
 1d4:	0c c0       	rjmp	.+24     	; 0x1ee <gpioPinRead+0x28>
				
				case 0:
				u8_value =	 (PORTA_PIN & u8_pin ) ;
 1d6:	89 b3       	in	r24, 0x19	; 25
 1d8:	68 23       	and	r22, r24
						break;
 1da:	0a c0       	rjmp	.+20     	; 0x1f0 <gpioPinRead+0x2a>
				case 1:
				u8_value =	 (PORTB_PIN & u8_pin ) ;
 1dc:	86 b3       	in	r24, 0x16	; 22
 1de:	68 23       	and	r22, r24
						break;
 1e0:	07 c0       	rjmp	.+14     	; 0x1f0 <gpioPinRead+0x2a>
				case 2:
				u8_value =	 (PORTC_PIN & u8_pin ) ;
 1e2:	83 b3       	in	r24, 0x13	; 19
 1e4:	68 23       	and	r22, r24
						break;
 1e6:	04 c0       	rjmp	.+8      	; 0x1f0 <gpioPinRead+0x2a>
				case 3:
				u8_value =	(PORTD_PIN & u8_pin ) ;
 1e8:	80 b3       	in	r24, 0x10	; 16
 1ea:	68 23       	and	r22, r24
						break;
 1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <gpioPinRead+0x2a>
 * 				- BIT7
 * @return
 */
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin){
	
			uint8_t	u8_value = 0;
 1ee:	60 e0       	ldi	r22, 0x00	; 0
 1f0:	81 e0       	ldi	r24, 0x01	; 1
 1f2:	61 11       	cpse	r22, r1
 1f4:	01 c0       	rjmp	.+2      	; 0x1f8 <gpioPinRead+0x32>
 1f6:	80 e0       	ldi	r24, 0x00	; 0
			{
				return 1;
			} else {
				return 0;
			}
}
 1f8:	08 95       	ret

000001fa <Led_Init>:

#include "led.h"

void Led_Init(En_LedNumber_t en_led_id){
	
	switch(en_led_id){
 1fa:	81 30       	cpi	r24, 0x01	; 1
 1fc:	89 f0       	breq	.+34     	; 0x220 <Led_Init+0x26>
 1fe:	28 f0       	brcs	.+10     	; 0x20a <Led_Init+0x10>
 200:	82 30       	cpi	r24, 0x02	; 2
 202:	c9 f0       	breq	.+50     	; 0x236 <Led_Init+0x3c>
 204:	83 30       	cpi	r24, 0x03	; 3
 206:	11 f1       	breq	.+68     	; 0x24c <Led_Init+0x52>
 208:	08 95       	ret
		
		case LED_0:
				gpioPinDirection( LED_0_GPIO, LED_0_BIT, OUTPUT );
 20a:	4f ef       	ldi	r20, 0xFF	; 255
 20c:	60 e1       	ldi	r22, 0x10	; 16
 20e:	81 e0       	ldi	r24, 0x01	; 1
 210:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				gpioPinWrite(LED_0_GPIO, LED_0_BIT, LOW);
 214:	40 e0       	ldi	r20, 0x00	; 0
 216:	60 e1       	ldi	r22, 0x10	; 16
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
					break;
 21e:	08 95       	ret
		case LED_1:
				gpioPinDirection( LED_1_GPIO, LED_1_BIT, OUTPUT );
 220:	4f ef       	ldi	r20, 0xFF	; 255
 222:	60 e2       	ldi	r22, 0x20	; 32
 224:	81 e0       	ldi	r24, 0x01	; 1
 226:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				gpioPinWrite(LED_1_GPIO, LED_1_BIT, LOW);		
 22a:	40 e0       	ldi	r20, 0x00	; 0
 22c:	60 e2       	ldi	r22, 0x20	; 32
 22e:	81 e0       	ldi	r24, 0x01	; 1
 230:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
					break;
 234:	08 95       	ret
		case LED_2:
				gpioPinDirection( LED_2_GPIO, LED_2_BIT, OUTPUT );
 236:	4f ef       	ldi	r20, 0xFF	; 255
 238:	60 e4       	ldi	r22, 0x40	; 64
 23a:	81 e0       	ldi	r24, 0x01	; 1
 23c:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				gpioPinWrite(LED_2_GPIO, LED_2_BIT, LOW);		
 240:	40 e0       	ldi	r20, 0x00	; 0
 242:	60 e4       	ldi	r22, 0x40	; 64
 244:	81 e0       	ldi	r24, 0x01	; 1
 246:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
					break;
 24a:	08 95       	ret
		case LED_3:
				gpioPinDirection( LED_3_GPIO, LED_3_BIT, OUTPUT );
 24c:	4f ef       	ldi	r20, 0xFF	; 255
 24e:	60 e8       	ldi	r22, 0x80	; 128
 250:	81 e0       	ldi	r24, 0x01	; 1
 252:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				gpioPinWrite(LED_3_GPIO, LED_3_BIT, LOW);		
 256:	40 e0       	ldi	r20, 0x00	; 0
 258:	60 e8       	ldi	r22, 0x80	; 128
 25a:	81 e0       	ldi	r24, 0x01	; 1
 25c:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
 260:	08 95       	ret

00000262 <Led_On>:
 * 				  one of the enum (En_LedNumber_t) parameters
 *
 */
void Led_On(En_LedNumber_t en_led_id){
	
	switch(en_led_id){
 262:	81 30       	cpi	r24, 0x01	; 1
 264:	61 f0       	breq	.+24     	; 0x27e <Led_On+0x1c>
 266:	28 f0       	brcs	.+10     	; 0x272 <Led_On+0x10>
 268:	82 30       	cpi	r24, 0x02	; 2
 26a:	79 f0       	breq	.+30     	; 0x28a <Led_On+0x28>
 26c:	83 30       	cpi	r24, 0x03	; 3
 26e:	99 f0       	breq	.+38     	; 0x296 <Led_On+0x34>
 270:	08 95       	ret
		
		case LED_0:
			gpioPinWrite(LED_0_GPIO, LED_0_BIT, HIGH);
 272:	4f ef       	ldi	r20, 0xFF	; 255
 274:	60 e1       	ldi	r22, 0x10	; 16
 276:	81 e0       	ldi	r24, 0x01	; 1
 278:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
			break;
 27c:	08 95       	ret
		case LED_1:
			gpioPinWrite(LED_1_GPIO, LED_1_BIT, HIGH);
 27e:	4f ef       	ldi	r20, 0xFF	; 255
 280:	60 e2       	ldi	r22, 0x20	; 32
 282:	81 e0       	ldi	r24, 0x01	; 1
 284:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
			break;
 288:	08 95       	ret
		case LED_2:
			gpioPinWrite(LED_2_GPIO, LED_2_BIT, HIGH);
 28a:	4f ef       	ldi	r20, 0xFF	; 255
 28c:	60 e4       	ldi	r22, 0x40	; 64
 28e:	81 e0       	ldi	r24, 0x01	; 1
 290:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
			break;
 294:	08 95       	ret
		case LED_3:
			gpioPinWrite(LED_3_GPIO, LED_3_BIT, HIGH);
 296:	4f ef       	ldi	r20, 0xFF	; 255
 298:	60 e8       	ldi	r22, 0x80	; 128
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
 2a0:	08 95       	ret

000002a2 <Led_Off>:
 * 				  one of the enum (En_LedNumber_t) parameters
 *
 */
void Led_Off(En_LedNumber_t en_led_id){
	
	switch(en_led_id){
 2a2:	81 30       	cpi	r24, 0x01	; 1
 2a4:	61 f0       	breq	.+24     	; 0x2be <Led_Off+0x1c>
 2a6:	28 f0       	brcs	.+10     	; 0x2b2 <Led_Off+0x10>
 2a8:	82 30       	cpi	r24, 0x02	; 2
 2aa:	79 f0       	breq	.+30     	; 0x2ca <Led_Off+0x28>
 2ac:	83 30       	cpi	r24, 0x03	; 3
 2ae:	99 f0       	breq	.+38     	; 0x2d6 <Led_Off+0x34>
 2b0:	08 95       	ret
		
		case LED_0:
				gpioPinWrite(LED_0_GPIO, LED_0_BIT, LOW);
 2b2:	40 e0       	ldi	r20, 0x00	; 0
 2b4:	60 e1       	ldi	r22, 0x10	; 16
 2b6:	81 e0       	ldi	r24, 0x01	; 1
 2b8:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
				break;
 2bc:	08 95       	ret
		case LED_1:
				gpioPinWrite(LED_1_GPIO, LED_1_BIT, LOW);
 2be:	40 e0       	ldi	r20, 0x00	; 0
 2c0:	60 e2       	ldi	r22, 0x20	; 32
 2c2:	81 e0       	ldi	r24, 0x01	; 1
 2c4:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
				break;
 2c8:	08 95       	ret
		case LED_2:
				gpioPinWrite(LED_2_GPIO, LED_2_BIT, LOW);
 2ca:	40 e0       	ldi	r20, 0x00	; 0
 2cc:	60 e4       	ldi	r22, 0x40	; 64
 2ce:	81 e0       	ldi	r24, 0x01	; 1
 2d0:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
				break;
 2d4:	08 95       	ret
		case LED_3:
				gpioPinWrite(LED_3_GPIO, LED_3_BIT, LOW);
 2d6:	40 e0       	ldi	r20, 0x00	; 0
 2d8:	60 e8       	ldi	r22, 0x80	; 128
 2da:	81 e0       	ldi	r24, 0x01	; 1
 2dc:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
 2e0:	08 95       	ret

000002e2 <REQ1_Start>:
 * 
 *
 */
void REQ1_Start(void)
{
	sevenSegInit(SEG_0);
 2e2:	80 e0       	ldi	r24, 0x00	; 0
 2e4:	0e 94 72 02 	call	0x4e4	; 0x4e4 <sevenSegInit>
	sevenSegInit(SEG_1);
 2e8:	81 e0       	ldi	r24, 0x01	; 1
 2ea:	0e 94 72 02 	call	0x4e4	; 0x4e4 <sevenSegInit>
		for ( sevSegNumber = 0; sevSegNumber < 100 ; sevSegNumber++ )
		{
			for (int cnt=0; cnt<10; cnt++)
			{
				sevenSegEnable(SEG_0);
				sevenSegWrite(SEG_0, sevSegNumber / 10 );
 2ee:	0f 2e       	mov	r0, r31
 2f0:	fd ec       	ldi	r31, 0xCD	; 205
 2f2:	ef 2e       	mov	r14, r31
 2f4:	f0 2d       	mov	r31, r0
{
	sevenSegInit(SEG_0);
	sevenSegInit(SEG_1);
	uint8_t sevSegNumber = 0;
	while(1){
		for ( sevSegNumber = 0; sevSegNumber < 100 ; sevSegNumber++ )
 2f6:	f1 2c       	mov	r15, r1
 2f8:	22 c0       	rjmp	.+68     	; 0x33e <REQ1_Start+0x5c>
		{
			for (int cnt=0; cnt<10; cnt++)
			{
				sevenSegEnable(SEG_0);
 2fa:	80 e0       	ldi	r24, 0x00	; 0
 2fc:	0e 94 8a 02 	call	0x514	; 0x514 <sevenSegEnable>
				sevenSegWrite(SEG_0, sevSegNumber / 10 );
 300:	61 2f       	mov	r22, r17
 302:	80 e0       	ldi	r24, 0x00	; 0
 304:	0e 94 ac 02 	call	0x558	; 0x558 <sevenSegWrite>
				//softwareDelayMs(50);
				timer0DelayMs(20);
 308:	84 e1       	ldi	r24, 0x14	; 20
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	0e 94 44 03 	call	0x688	; 0x688 <timer0DelayMs>
				sevenSegDisable(SEG_0);
 310:	80 e0       	ldi	r24, 0x00	; 0
 312:	0e 94 9b 02 	call	0x536	; 0x536 <sevenSegDisable>
				
				
				sevenSegEnable(SEG_1);
 316:	81 e0       	ldi	r24, 0x01	; 1
 318:	0e 94 8a 02 	call	0x514	; 0x514 <sevenSegEnable>
				sevenSegWrite(SEG_1, sevSegNumber % 10 );
 31c:	60 2f       	mov	r22, r16
 31e:	81 e0       	ldi	r24, 0x01	; 1
 320:	0e 94 ac 02 	call	0x558	; 0x558 <sevenSegWrite>
				//softwareDelayMs(50);
				timer0DelayMs(20);
 324:	84 e1       	ldi	r24, 0x14	; 20
 326:	90 e0       	ldi	r25, 0x00	; 0
 328:	0e 94 44 03 	call	0x688	; 0x688 <timer0DelayMs>
				sevenSegDisable(SEG_1);
 32c:	81 e0       	ldi	r24, 0x01	; 1
 32e:	0e 94 9b 02 	call	0x536	; 0x536 <sevenSegDisable>
 332:	21 97       	sbiw	r28, 0x01	; 1
	sevenSegInit(SEG_1);
	uint8_t sevSegNumber = 0;
	while(1){
		for ( sevSegNumber = 0; sevSegNumber < 100 ; sevSegNumber++ )
		{
			for (int cnt=0; cnt<10; cnt++)
 334:	11 f7       	brne	.-60     	; 0x2fa <REQ1_Start+0x18>
{
	sevenSegInit(SEG_0);
	sevenSegInit(SEG_1);
	uint8_t sevSegNumber = 0;
	while(1){
		for ( sevSegNumber = 0; sevSegNumber < 100 ; sevSegNumber++ )
 336:	f3 94       	inc	r15
 338:	84 e6       	ldi	r24, 0x64	; 100
 33a:	f8 16       	cp	r15, r24
 33c:	e1 f2       	breq	.-72     	; 0x2f6 <REQ1_Start+0x14>
		{
			for (int cnt=0; cnt<10; cnt++)
			{
				sevenSegEnable(SEG_0);
				sevenSegWrite(SEG_0, sevSegNumber / 10 );
 33e:	fe 9c       	mul	r15, r14
 340:	11 2d       	mov	r17, r1
 342:	11 24       	eor	r1, r1
 344:	16 95       	lsr	r17
 346:	16 95       	lsr	r17
 348:	16 95       	lsr	r17
				timer0DelayMs(20);
				sevenSegDisable(SEG_0);
				
				
				sevenSegEnable(SEG_1);
				sevenSegWrite(SEG_1, sevSegNumber % 10 );
 34a:	91 2f       	mov	r25, r17
 34c:	99 0f       	add	r25, r25
 34e:	89 2f       	mov	r24, r25
 350:	88 0f       	add	r24, r24
 352:	88 0f       	add	r24, r24
 354:	89 0f       	add	r24, r25
 356:	0f 2d       	mov	r16, r15
 358:	08 1b       	sub	r16, r24
 35a:	ca e0       	ldi	r28, 0x0A	; 10
 35c:	d0 e0       	ldi	r29, 0x00	; 0
 35e:	cd cf       	rjmp	.-102    	; 0x2fa <REQ1_Start+0x18>

00000360 <REQ2_Start>:
		second presses is less than 1s, the LED 1 will be on for 2 seconds then off
		If the time between them is more than 1s then the led will be turned off after 1s
 */
void REQ2_Start(void)
{
	Led_Init(LED_1);
 360:	81 e0       	ldi	r24, 0x01	; 1
 362:	0e 94 fd 00 	call	0x1fa	; 0x1fa <Led_Init>
	uint8_t pressCounts = 0 ;
	uint8_t internalPress = 0;
	
	while(1){
		pressCounts = 0 ;
		internalPress = 0;
 366:	00 e0       	ldi	r16, 0x00	; 0
		if (pushButtonGetStatus(BTN_1) == Prepressed)
 368:	81 e0       	ldi	r24, 0x01	; 1
 36a:	0e 94 54 02 	call	0x4a8	; 0x4a8 <pushButtonGetStatus>
 36e:	81 30       	cpi	r24, 0x01	; 1
 370:	29 f5       	brne	.+74     	; 0x3bc <REQ2_Start+0x5c>
		{
			//softwareDelayMs(20);
			timer0DelayMs(20);
 372:	84 e1       	ldi	r24, 0x14	; 20
 374:	90 e0       	ldi	r25, 0x00	; 0
 376:	0e 94 44 03 	call	0x688	; 0x688 <timer0DelayMs>
			if (pushButtonGetStatus(BTN_1) == Prepressed)
 37a:	81 e0       	ldi	r24, 0x01	; 1
 37c:	0e 94 54 02 	call	0x4a8	; 0x4a8 <pushButtonGetStatus>
 380:	81 30       	cpi	r24, 0x01	; 1
 382:	c1 f4       	brne	.+48     	; 0x3b4 <REQ2_Start+0x54>
			{
				if (pressCounts == 0)
				{
					pressCounts++;
					Led_On(LED_1);
 384:	0e 94 31 01 	call	0x262	; 0x262 <Led_On>
 388:	c5 e0       	ldi	r28, 0x05	; 5
 38a:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t pressCounts = 0 ;
	uint8_t internalPress = 0;
	
	while(1){
		pressCounts = 0 ;
		internalPress = 0;
 38c:	10 2f       	mov	r17, r16
					/* break the blocking time to be able to listen */
					
							for (int i = 0; i < 5; i++){
								
								//	softwareDelayMs(200);
								timer0DelayMs(200);
 38e:	88 ec       	ldi	r24, 0xC8	; 200
 390:	90 e0       	ldi	r25, 0x00	; 0
 392:	0e 94 44 03 	call	0x688	; 0x688 <timer0DelayMs>

								if (pushButtonGetStatus(BTN_1) == Prepressed){
 396:	81 e0       	ldi	r24, 0x01	; 1
 398:	0e 94 54 02 	call	0x4a8	; 0x4a8 <pushButtonGetStatus>
 39c:	81 30       	cpi	r24, 0x01	; 1
 39e:	09 f4       	brne	.+2      	; 0x3a2 <REQ2_Start+0x42>
										internalPress = 1;
 3a0:	11 e0       	ldi	r17, 0x01	; 1
 3a2:	21 97       	sbiw	r28, 0x01	; 1
				{
					pressCounts++;
					Led_On(LED_1);
					/* break the blocking time to be able to listen */
					
							for (int i = 0; i < 5; i++){
 3a4:	a1 f7       	brne	.-24     	; 0x38e <REQ2_Start+0x2e>
								if (pushButtonGetStatus(BTN_1) == Prepressed){
										internalPress = 1;
											}
										  }
					
											if (internalPress == 0)
 3a6:	11 23       	and	r17, r17
 3a8:	f9 f2       	breq	.-66     	; 0x368 <REQ2_Start+0x8>
												{
													pressCounts = 0;
												}else {
														pressCounts++;
														//softwareDelayMs(1000);
														timer0DelayMs(1000);
 3aa:	88 ee       	ldi	r24, 0xE8	; 232
 3ac:	93 e0       	ldi	r25, 0x03	; 3
 3ae:	0e 94 44 03 	call	0x688	; 0x688 <timer0DelayMs>
 3b2:	da cf       	rjmp	.-76     	; 0x368 <REQ2_Start+0x8>
																		}
					}
				} else {
				Led_Off(LED_1);
 3b4:	81 e0       	ldi	r24, 0x01	; 1
 3b6:	0e 94 51 01 	call	0x2a2	; 0x2a2 <Led_Off>
 3ba:	d6 cf       	rjmp	.-84     	; 0x368 <REQ2_Start+0x8>
			}
			} else {
			Led_Off(LED_1);
 3bc:	81 e0       	ldi	r24, 0x01	; 1
 3be:	0e 94 51 01 	call	0x2a2	; 0x2a2 <Led_Off>
 3c2:	d2 cf       	rjmp	.-92     	; 0x368 <REQ2_Start+0x8>

000003c4 <Go_State>:
	
}

void Go_State(void)
{
	Led_On(LED_1);
 3c4:	81 e0       	ldi	r24, 0x01	; 1
 3c6:	0e 94 31 01 	call	0x262	; 0x262 <Led_On>
	//softwareDelayMs(1000);
	timer0DelayMs(1000);
 3ca:	88 ee       	ldi	r24, 0xE8	; 232
 3cc:	93 e0       	ldi	r25, 0x03	; 3
 3ce:	0e 94 44 03 	call	0x688	; 0x688 <timer0DelayMs>
	Led_Off(LED_1);
 3d2:	81 e0       	ldi	r24, 0x01	; 1
 3d4:	0e 94 51 01 	call	0x2a2	; 0x2a2 <Led_Off>
 3d8:	08 95       	ret

000003da <Ready_State>:
}

void Ready_State(void)
{
	Led_On(LED_2);
 3da:	82 e0       	ldi	r24, 0x02	; 2
 3dc:	0e 94 31 01 	call	0x262	; 0x262 <Led_On>
	//softwareDelayMs(1000);
	timer0DelayMs(1000);
 3e0:	88 ee       	ldi	r24, 0xE8	; 232
 3e2:	93 e0       	ldi	r25, 0x03	; 3
 3e4:	0e 94 44 03 	call	0x688	; 0x688 <timer0DelayMs>

	Led_Off(LED_2);
 3e8:	82 e0       	ldi	r24, 0x02	; 2
 3ea:	0e 94 51 01 	call	0x2a2	; 0x2a2 <Led_Off>
 3ee:	08 95       	ret

000003f0 <Stop_State>:
}

void Stop_State(void)
{
	Led_On(LED_3);
 3f0:	83 e0       	ldi	r24, 0x03	; 3
 3f2:	0e 94 31 01 	call	0x262	; 0x262 <Led_On>
	//softwareDelayMs(1000);
	timer0DelayMs(1000);
 3f6:	88 ee       	ldi	r24, 0xE8	; 232
 3f8:	93 e0       	ldi	r25, 0x03	; 3
 3fa:	0e 94 44 03 	call	0x688	; 0x688 <timer0DelayMs>

	Led_Off(LED_3);
 3fe:	83 e0       	ldi	r24, 0x03	; 3
 400:	0e 94 51 01 	call	0x2a2	; 0x2a2 <Led_Off>
 404:	08 95       	ret

00000406 <REQ3_Start>:
 *
 */

void REQ3_Start(void)
{
	Led_Init(LED_1);
 406:	81 e0       	ldi	r24, 0x01	; 1
 408:	0e 94 fd 00 	call	0x1fa	; 0x1fa <Led_Init>
	Led_Init(LED_2);
 40c:	82 e0       	ldi	r24, 0x02	; 2
 40e:	0e 94 fd 00 	call	0x1fa	; 0x1fa <Led_Init>
	Led_Init(LED_3);
 412:	83 e0       	ldi	r24, 0x03	; 3
 414:	0e 94 fd 00 	call	0x1fa	; 0x1fa <Led_Init>
	
	uint8_t State = 0;
 418:	80 e0       	ldi	r24, 0x00	; 0
			Go_State();
			State = 1;
			break;
			case 1:
			Ready_State();
			State = 2;
 41a:	12 e0       	ldi	r17, 0x02	; 2
	for (;;)
	{
		switch(State){
			case 0:
			Go_State();
			State = 1;
 41c:	d1 e0       	ldi	r29, 0x01	; 1
			Ready_State();
			State = 2;
			break;
			case 2:
			Stop_State();
			State = 0;
 41e:	c0 e0       	ldi	r28, 0x00	; 0
	Led_Init(LED_3);
	
	uint8_t State = 0;
	for (;;)
	{
		switch(State){
 420:	81 30       	cpi	r24, 0x01	; 1
 422:	41 f0       	breq	.+16     	; 0x434 <REQ3_Start+0x2e>
 424:	18 f0       	brcs	.+6      	; 0x42c <REQ3_Start+0x26>
 426:	82 30       	cpi	r24, 0x02	; 2
 428:	49 f0       	breq	.+18     	; 0x43c <REQ3_Start+0x36>
 42a:	fa cf       	rjmp	.-12     	; 0x420 <REQ3_Start+0x1a>
			case 0:
			Go_State();
 42c:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <Go_State>
			State = 1;
 430:	8d 2f       	mov	r24, r29
			break;
 432:	f6 cf       	rjmp	.-20     	; 0x420 <REQ3_Start+0x1a>
			case 1:
			Ready_State();
 434:	0e 94 ed 01 	call	0x3da	; 0x3da <Ready_State>
			State = 2;
 438:	81 2f       	mov	r24, r17
			break;
 43a:	f2 cf       	rjmp	.-28     	; 0x420 <REQ3_Start+0x1a>
			case 2:
			Stop_State();
 43c:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <Stop_State>
			State = 0;
 440:	8c 2f       	mov	r24, r28
			break;
 442:	ee cf       	rjmp	.-36     	; 0x420 <REQ3_Start+0x1a>

00000444 <main>:
	 }
	  END OF TESTING SW PWM */
		
		
			
	timer1Init(T1_NORMAL_MODE, T1_OC1_DIS, T1_PRESCALER_64, 0, 0, 0, 0, T1_POLLING);
 444:	a1 2c       	mov	r10, r1
 446:	c1 2c       	mov	r12, r1
 448:	d1 2c       	mov	r13, r1
 44a:	e1 2c       	mov	r14, r1
 44c:	f1 2c       	mov	r15, r1
 44e:	00 e0       	ldi	r16, 0x00	; 0
 450:	10 e0       	ldi	r17, 0x00	; 0
 452:	20 e0       	ldi	r18, 0x00	; 0
 454:	30 e0       	ldi	r19, 0x00	; 0
 456:	43 e0       	ldi	r20, 0x03	; 3
 458:	60 e0       	ldi	r22, 0x00	; 0
 45a:	70 e0       	ldi	r23, 0x00	; 0
 45c:	80 e0       	ldi	r24, 0x00	; 0
 45e:	0e 94 5e 03 	call	0x6bc	; 0x6bc <timer1Init>
     
	 SREG |= (1<<7); 	
 462:	8f b7       	in	r24, 0x3f	; 63
 464:	80 68       	ori	r24, 0x80	; 128
 466:	8f bf       	out	0x3f, r24	; 63
		 
	/* dip switch to choose the requirement to show */
	
	uint8_t REQ_Select = 0;
	
	timer0Init(T0_NORMAL_MODE, T0_OC0_DIS, T0_PRESCALER_64, 0,0, T0_POLLING);
 468:	20 e0       	ldi	r18, 0x00	; 0
 46a:	43 e0       	ldi	r20, 0x03	; 3
 46c:	60 e0       	ldi	r22, 0x00	; 0
 46e:	80 e0       	ldi	r24, 0x00	; 0
 470:	0e 94 2a 03 	call	0x654	; 0x654 <timer0Init>

	gpioPinDirection(GPIOA, (BIT5 | BIT6 | BIT7), INPUT);
 474:	40 e0       	ldi	r20, 0x00	; 0
 476:	60 ee       	ldi	r22, 0xE0	; 224
 478:	80 e0       	ldi	r24, 0x00	; 0
 47a:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
	gpioPortWrite(GPIOA, (BIT5 | BIT6 | BIT7));
 47e:	60 ee       	ldi	r22, 0xE0	; 224
 480:	80 e0       	ldi	r24, 0x00	; 0
 482:	0e 94 59 00 	call	0xb2	; 0xb2 <gpioPortWrite>
	
	REQ_Select = gpioPortRead(GPIOA);
 486:	80 e0       	ldi	r24, 0x00	; 0
 488:	0e 94 69 00 	call	0xd2	; 0xd2 <gpioPortRead>
	
	switch(REQ_Select){
 48c:	80 3a       	cpi	r24, 0xA0	; 160
 48e:	39 f0       	breq	.+14     	; 0x49e <main+0x5a>
 490:	80 3c       	cpi	r24, 0xC0	; 192
 492:	19 f0       	breq	.+6      	; 0x49a <main+0x56>
 494:	80 36       	cpi	r24, 0x60	; 96
 496:	29 f0       	breq	.+10     	; 0x4a2 <main+0x5e>
 498:	06 c0       	rjmp	.+12     	; 0x4a6 <main+0x62>
		
		case 192: //110
			REQ1_Start();
 49a:	0e 94 71 01 	call	0x2e2	; 0x2e2 <REQ1_Start>
			break;
		case 160: //101
			REQ2_Start();
 49e:	0e 94 b0 01 	call	0x360	; 0x360 <REQ2_Start>
			break;
		case 96:// 011
			REQ3_Start();
 4a2:	0e 94 03 02 	call	0x406	; 0x406 <REQ3_Start>
 4a6:	ff cf       	rjmp	.-2      	; 0x4a6 <main+0x62>

000004a8 <pushButtonGetStatus>:
 */
En_buttonStatus_t pushButtonGetStatus(En_buttonId_t en_butotn_id){
		
	uint8_t current_state = 0;
		
	switch(en_butotn_id){
 4a8:	81 30       	cpi	r24, 0x01	; 1
 4aa:	59 f0       	breq	.+22     	; 0x4c2 <pushButtonGetStatus+0x1a>
 4ac:	28 f0       	brcs	.+10     	; 0x4b8 <pushButtonGetStatus+0x10>
 4ae:	82 30       	cpi	r24, 0x02	; 2
 4b0:	69 f0       	breq	.+26     	; 0x4cc <pushButtonGetStatus+0x24>
 4b2:	83 30       	cpi	r24, 0x03	; 3
 4b4:	81 f0       	breq	.+32     	; 0x4d6 <pushButtonGetStatus+0x2e>
 4b6:	14 c0       	rjmp	.+40     	; 0x4e0 <pushButtonGetStatus+0x38>
		
		case BTN_0:
				current_state = gpioPinRead( BTN_0_GPIO, BTN_0_BIT );
 4b8:	60 e1       	ldi	r22, 0x10	; 16
 4ba:	82 e0       	ldi	r24, 0x02	; 2
 4bc:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <gpioPinRead>
				break;
 4c0:	08 95       	ret
		case BTN_1:
				current_state =	gpioPinRead( BTN_1_GPIO, BTN_1_BIT );
 4c2:	64 e0       	ldi	r22, 0x04	; 4
 4c4:	81 e0       	ldi	r24, 0x01	; 1
 4c6:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <gpioPinRead>
				break;
 4ca:	08 95       	ret
		case BTN_2:
				current_state = gpioPinRead( BTN_2_GPIO, BTN_2_BIT );
 4cc:	64 e0       	ldi	r22, 0x04	; 4
 4ce:	80 e0       	ldi	r24, 0x00	; 0
 4d0:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <gpioPinRead>
				break;
 4d4:	08 95       	ret
		case BTN_3:
				current_state = gpioPinRead( BTN_3_GPIO, BTN_3_BIT );
 4d6:	68 e0       	ldi	r22, 0x08	; 8
 4d8:	80 e0       	ldi	r24, 0x00	; 0
 4da:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <gpioPinRead>
				break;
 4de:	08 95       	ret
 * 				in the update function
 *
 */
En_buttonStatus_t pushButtonGetStatus(En_buttonId_t en_butotn_id){
		
	uint8_t current_state = 0;
 4e0:	80 e0       	ldi	r24, 0x00	; 0
				current_state = gpioPinRead( BTN_3_GPIO, BTN_3_BIT );
				break;
		default:break;
	}
	return current_state;
 4e2:	08 95       	ret

000004e4 <sevenSegInit>:

/**
 * Description:  initialize seven segment data port as output
 * @param a_segment_id
 */
void sevenSegInit(En_SevenSegId_t a_segment_id){
 4e4:	cf 93       	push	r28
 4e6:	c8 2f       	mov	r28, r24
	
	gpioPortDirection(SEG_BCD_GPIO, OUTPUT); // bcd is common for the two segments 
 4e8:	6f ef       	ldi	r22, 0xFF	; 255
 4ea:	81 e0       	ldi	r24, 0x01	; 1
 4ec:	0e 94 49 00 	call	0x92	; 0x92 <gpioPortDirection>
	
	switch(a_segment_id){
 4f0:	cc 23       	and	r28, r28
 4f2:	19 f0       	breq	.+6      	; 0x4fa <sevenSegInit+0x16>
 4f4:	c1 30       	cpi	r28, 0x01	; 1
 4f6:	39 f0       	breq	.+14     	; 0x506 <sevenSegInit+0x22>
 4f8:	0b c0       	rjmp	.+22     	; 0x510 <sevenSegInit+0x2c>
		
		case SEG_0:
				gpioPinDirection(SEG_EN1_GPIO, SEG_EN1_BIT, OUTPUT);
 4fa:	4f ef       	ldi	r20, 0xFF	; 255
 4fc:	64 e0       	ldi	r22, 0x04	; 4
 4fe:	83 e0       	ldi	r24, 0x03	; 3
 500:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				break;
 504:	05 c0       	rjmp	.+10     	; 0x510 <sevenSegInit+0x2c>
				
		case SEG_1:
				gpioPinDirection(SEG_EN2_GPIO, SEG_EN2_BIT, OUTPUT);
 506:	4f ef       	ldi	r20, 0xFF	; 255
 508:	68 e0       	ldi	r22, 0x08	; 8
 50a:	83 e0       	ldi	r24, 0x03	; 3
 50c:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				break;
		
		default: break;
	}
}
 510:	cf 91       	pop	r28
 512:	08 95       	ret

00000514 <sevenSegEnable>:
 * Description:  enable the enable bits of the 7 segment to be able to write 
 * @param en_segment_id
 */
void sevenSegEnable(En_SevenSegId_t en_segment_id){
	
	switch(en_segment_id){
 514:	88 23       	and	r24, r24
 516:	19 f0       	breq	.+6      	; 0x51e <sevenSegEnable+0xa>
 518:	81 30       	cpi	r24, 0x01	; 1
 51a:	39 f0       	breq	.+14     	; 0x52a <sevenSegEnable+0x16>
 51c:	08 95       	ret
		
		case SEG_0:
					gpioPinWrite(SEG_EN1_GPIO, SEG_EN1_BIT, HIGH);
 51e:	4f ef       	ldi	r20, 0xFF	; 255
 520:	64 e0       	ldi	r22, 0x04	; 4
 522:	83 e0       	ldi	r24, 0x03	; 3
 524:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
					break;
 528:	08 95       	ret
		case SEG_1:
					gpioPinWrite(SEG_EN2_GPIO, SEG_EN2_BIT, HIGH);
 52a:	4f ef       	ldi	r20, 0xFF	; 255
 52c:	68 e0       	ldi	r22, 0x08	; 8
 52e:	83 e0       	ldi	r24, 0x03	; 3
 530:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
 534:	08 95       	ret

00000536 <sevenSegDisable>:
 * Description: disable the enable bits of 7 segment 
 * @param en_segment_id
 */
void sevenSegDisable(En_SevenSegId_t en_segment_id){
	
		switch(en_segment_id){
 536:	88 23       	and	r24, r24
 538:	19 f0       	breq	.+6      	; 0x540 <sevenSegDisable+0xa>
 53a:	81 30       	cpi	r24, 0x01	; 1
 53c:	39 f0       	breq	.+14     	; 0x54c <sevenSegDisable+0x16>
 53e:	08 95       	ret
			
			case SEG_0:
					gpioPinWrite(SEG_EN1_GPIO, SEG_EN1_BIT, LOW);
 540:	40 e0       	ldi	r20, 0x00	; 0
 542:	64 e0       	ldi	r22, 0x04	; 4
 544:	83 e0       	ldi	r24, 0x03	; 3
 546:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
					break;
 54a:	08 95       	ret
			case SEG_1:
					gpioPinWrite(SEG_EN2_GPIO, SEG_EN2_BIT, LOW);
 54c:	40 e0       	ldi	r20, 0x00	; 0
 54e:	68 e0       	ldi	r22, 0x08	; 8
 550:	83 e0       	ldi	r24, 0x03	; 3
 552:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
 556:	08 95       	ret

00000558 <sevenSegWrite>:

/**
 * Description: writes a digit on 7 segment 
 * @param en_segment_id, digit
 */
void sevenSegWrite(En_SevenSegId_t en_segment_id , uint8_t digit ){
 558:	cf 93       	push	r28
 55a:	c6 2f       	mov	r28, r22
	
	switch(en_segment_id){
 55c:	88 23       	and	r24, r24
 55e:	19 f0       	breq	.+6      	; 0x566 <sevenSegWrite+0xe>
 560:	81 30       	cpi	r24, 0x01	; 1
 562:	59 f0       	breq	.+22     	; 0x57a <sevenSegWrite+0x22>
 564:	13 c0       	rjmp	.+38     	; 0x58c <sevenSegWrite+0x34>
		
		case SEG_0:
					gpioPortWrite(SEG_BCD_GPIO, LOW);
 566:	60 e0       	ldi	r22, 0x00	; 0
 568:	81 e0       	ldi	r24, 0x01	; 1
 56a:	0e 94 59 00 	call	0xb2	; 0xb2 <gpioPortWrite>
					gpioPortWrite(SEG_BCD_GPIO, BCD_WRITE_MASK & digit);
 56e:	6c 2f       	mov	r22, r28
 570:	6f 70       	andi	r22, 0x0F	; 15
 572:	81 e0       	ldi	r24, 0x01	; 1
 574:	0e 94 59 00 	call	0xb2	; 0xb2 <gpioPortWrite>
					break;
 578:	09 c0       	rjmp	.+18     	; 0x58c <sevenSegWrite+0x34>
		case SEG_1:
					gpioPortWrite(SEG_BCD_GPIO, LOW);
 57a:	60 e0       	ldi	r22, 0x00	; 0
 57c:	81 e0       	ldi	r24, 0x01	; 1
 57e:	0e 94 59 00 	call	0xb2	; 0xb2 <gpioPortWrite>
					gpioPortWrite(SEG_BCD_GPIO, BCD_WRITE_MASK & digit);
 582:	6c 2f       	mov	r22, r28
 584:	6f 70       	andi	r22, 0x0F	; 15
 586:	81 e0       	ldi	r24, 0x01	; 1
 588:	0e 94 59 00 	call	0xb2	; 0xb2 <gpioPortWrite>
					break;
		default: break;
	}
}
 58c:	cf 91       	pop	r28
 58e:	08 95       	ret

00000590 <SwICU_SetCfgEdge>:
void SwICU_Enable(void){
	GICR |= (1 << INT2_EN_BIT ); 
}

void SwICU_Disable(void){
	GICR &= ~(1 << INT2_EN_BIT); 
 590:	81 30       	cpi	r24, 0x01	; 1
 592:	21 f4       	brne	.+8      	; 0x59c <SwICU_SetCfgEdge+0xc>
 594:	84 b7       	in	r24, 0x34	; 52
 596:	80 64       	ori	r24, 0x40	; 64
 598:	84 bf       	out	0x34, r24	; 52
 59a:	08 95       	ret
 59c:	84 b7       	in	r24, 0x34	; 52
 59e:	8f 7b       	andi	r24, 0xBF	; 191
 5a0:	84 bf       	out	0x34, r24	; 52
 5a2:	08 95       	ret

000005a4 <__vector_3>:
}

/* SW ICU application */

ISR( INT2_vect) {
 5a4:	1f 92       	push	r1
 5a6:	0f 92       	push	r0
 5a8:	0f b6       	in	r0, 0x3f	; 63
 5aa:	0f 92       	push	r0
 5ac:	11 24       	eor	r1, r1
 5ae:	2f 93       	push	r18
 5b0:	3f 93       	push	r19
 5b2:	4f 93       	push	r20
 5b4:	5f 93       	push	r21
 5b6:	6f 93       	push	r22
 5b8:	7f 93       	push	r23
 5ba:	8f 93       	push	r24
 5bc:	9f 93       	push	r25
 5be:	af 93       	push	r26
 5c0:	bf 93       	push	r27
 5c2:	ef 93       	push	r30
 5c4:	ff 93       	push	r31
	
	static uint8_t edgeDetect = SwICU_EdgeRisiging;
	
	if (edgeDetect == SwICU_EdgeRisiging )
 5c6:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 5ca:	81 30       	cpi	r24, 0x01	; 1
 5cc:	71 f4       	brne	.+28     	; 0x5ea <__vector_3+0x46>
	timer0Stop();
}

void SwICU_Start(void){
	
	timer0Start();
 5ce:	0e 94 3a 03 	call	0x674	; 0x674 <timer0Start>
	if (edgeDetect == SwICU_EdgeRisiging )
	{

		SwICU_Start();
		
		GICR &= ~(1 << INT2_EN_BIT);
 5d2:	8b b7       	in	r24, 0x3b	; 59
 5d4:	8f 7d       	andi	r24, 0xDF	; 223
 5d6:	8b bf       	out	0x3b, r24	; 59
		SwICU_SetCfgEdge(SwICU_EdgeFalling);
 5d8:	80 e0       	ldi	r24, 0x00	; 0
 5da:	0e 94 c8 02 	call	0x590	; 0x590 <SwICU_SetCfgEdge>
		GICR |= (1 <<  INT2_EN_BIT);
 5de:	8b b7       	in	r24, 0x3b	; 59
 5e0:	80 62       	ori	r24, 0x20	; 32
 5e2:	8b bf       	out	0x3b, r24	; 59
		
		edgeDetect = SwICU_EdgeFalling;	
 5e4:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__data_start>
 5e8:	13 c0       	rjmp	.+38     	; 0x610 <__vector_3+0x6c>
	}
	
	else if (edgeDetect == SwICU_EdgeFalling )
 5ea:	81 11       	cpse	r24, r1
 5ec:	11 c0       	rjmp	.+34     	; 0x610 <__vector_3+0x6c>
	a_pu8_capt = timer0Read();
}

void SwICU_Stop(void){
	
	timer0Stop();
 5ee:	0e 94 40 03 	call	0x680	; 0x680 <timer0Stop>
	
	else if (edgeDetect == SwICU_EdgeFalling )
	{
		SwICU_Stop();
		
		SwICU_Reading = TCNT0;
 5f2:	82 b7       	in	r24, 0x32	; 50
 5f4:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <SwICU_Reading>
		//	TCNT0 = 0;
		GICR &= ~(1 << INT2_EN_BIT);
 5f8:	8b b7       	in	r24, 0x3b	; 59
 5fa:	8f 7d       	andi	r24, 0xDF	; 223
 5fc:	8b bf       	out	0x3b, r24	; 59
		SwICU_SetCfgEdge(SwICU_EdgeRisiging);
 5fe:	81 e0       	ldi	r24, 0x01	; 1
 600:	0e 94 c8 02 	call	0x590	; 0x590 <SwICU_SetCfgEdge>
		GICR |= (1 <<  INT2_EN_BIT);
 604:	8b b7       	in	r24, 0x3b	; 59
 606:	80 62       	ori	r24, 0x20	; 32
 608:	8b bf       	out	0x3b, r24	; 59
		
		edgeDetect = SwICU_EdgeRisiging;
 60a:	81 e0       	ldi	r24, 0x01	; 1
 60c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
	}
}
 610:	ff 91       	pop	r31
 612:	ef 91       	pop	r30
 614:	bf 91       	pop	r27
 616:	af 91       	pop	r26
 618:	9f 91       	pop	r25
 61a:	8f 91       	pop	r24
 61c:	7f 91       	pop	r23
 61e:	6f 91       	pop	r22
 620:	5f 91       	pop	r21
 622:	4f 91       	pop	r20
 624:	3f 91       	pop	r19
 626:	2f 91       	pop	r18
 628:	0f 90       	pop	r0
 62a:	0f be       	out	0x3f, r0	; 63
 62c:	0f 90       	pop	r0
 62e:	1f 90       	pop	r1
 630:	18 95       	reti

00000632 <__vector_11>:

ISR(TIMER0_OVF_vect){
 632:	1f 92       	push	r1
 634:	0f 92       	push	r0
 636:	0f b6       	in	r0, 0x3f	; 63
 638:	0f 92       	push	r0
 63a:	11 24       	eor	r1, r1
 63c:	8f 93       	push	r24
	
	SwICU_overflowCounter++;
 63e:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <SwICU_overflowCounter>
 642:	8f 5f       	subi	r24, 0xFF	; 255
 644:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <SwICU_overflowCounter>
}
 648:	8f 91       	pop	r24
 64a:	0f 90       	pop	r0
 64c:	0f be       	out	0x3f, r0	; 63
 64e:	0f 90       	pop	r0
 650:	1f 90       	pop	r1
 652:	18 95       	reti

00000654 <timer0Init>:
		
		while(!(TIFR & (1 << T2_OVF_FLAG)));
		TIFR |= (1 << T2_OVF_FLAG); // clear with writing one
	}
	timer2Stop();
}
 654:	ef 92       	push	r14
 656:	0f 93       	push	r16
 658:	93 b7       	in	r25, 0x33	; 51
 65a:	69 2b       	or	r22, r25
 65c:	86 2b       	or	r24, r22
 65e:	83 bf       	out	0x33, r24	; 51
 660:	22 bf       	out	0x32, r18	; 50
 662:	0c bf       	out	0x3c, r16	; 60
 664:	40 93 61 00 	sts	0x0061, r20	; 0x800061 <prescaler>
 668:	89 b7       	in	r24, 0x39	; 57
 66a:	e8 2a       	or	r14, r24
 66c:	e9 be       	out	0x39, r14	; 57
 66e:	0f 91       	pop	r16
 670:	ef 90       	pop	r14
 672:	08 95       	ret

00000674 <timer0Start>:
 674:	93 b7       	in	r25, 0x33	; 51
 676:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <prescaler>
 67a:	89 2b       	or	r24, r25
 67c:	83 bf       	out	0x33, r24	; 51
 67e:	08 95       	ret

00000680 <timer0Stop>:
 680:	83 b7       	in	r24, 0x33	; 51
 682:	88 7f       	andi	r24, 0xF8	; 248
 684:	83 bf       	out	0x33, r24	; 51
 686:	08 95       	ret

00000688 <timer0DelayMs>:
 688:	cf 93       	push	r28
 68a:	df 93       	push	r29
 68c:	ec 01       	movw	r28, r24
 68e:	0e 94 3a 03 	call	0x674	; 0x674 <timer0Start>
 692:	9e 01       	movw	r18, r28
 694:	21 50       	subi	r18, 0x01	; 1
 696:	31 09       	sbc	r19, r1
 698:	cd 2b       	or	r28, r29
 69a:	59 f0       	breq	.+22     	; 0x6b2 <timer0DelayMs+0x2a>
 69c:	96 e0       	ldi	r25, 0x06	; 6
 69e:	92 bf       	out	0x32, r25	; 50
 6a0:	08 b6       	in	r0, 0x38	; 56
 6a2:	00 fe       	sbrs	r0, 0
 6a4:	fd cf       	rjmp	.-6      	; 0x6a0 <timer0DelayMs+0x18>
 6a6:	88 b7       	in	r24, 0x38	; 56
 6a8:	81 60       	ori	r24, 0x01	; 1
 6aa:	88 bf       	out	0x38, r24	; 56
 6ac:	21 50       	subi	r18, 0x01	; 1
 6ae:	31 09       	sbc	r19, r1
 6b0:	b0 f7       	brcc	.-20     	; 0x69e <timer0DelayMs+0x16>
 6b2:	0e 94 40 03 	call	0x680	; 0x680 <timer0Stop>
 6b6:	df 91       	pop	r29
 6b8:	cf 91       	pop	r28
 6ba:	08 95       	ret

000006bc <timer1Init>:
 6bc:	af 92       	push	r10
 6be:	cf 92       	push	r12
 6c0:	df 92       	push	r13
 6c2:	ef 92       	push	r14
 6c4:	ff 92       	push	r15
 6c6:	0f 93       	push	r16
 6c8:	1f 93       	push	r17
 6ca:	ee b5       	in	r30, 0x2e	; 46
 6cc:	ff b5       	in	r31, 0x2f	; 47
 6ce:	6e 2b       	or	r22, r30
 6d0:	7f 2b       	or	r23, r31
 6d2:	68 2b       	or	r22, r24
 6d4:	7f bd       	out	0x2f, r23	; 47
 6d6:	6e bd       	out	0x2e, r22	; 46
 6d8:	3d bd       	out	0x2d, r19	; 45
 6da:	2c bd       	out	0x2c, r18	; 44
 6dc:	40 93 67 00 	sts	0x0067, r20	; 0x800067 <T1_prescaler>
 6e0:	1b bd       	out	0x2b, r17	; 43
 6e2:	0a bd       	out	0x2a, r16	; 42
 6e4:	f9 bc       	out	0x29, r15	; 41
 6e6:	e8 bc       	out	0x28, r14	; 40
 6e8:	d7 bc       	out	0x27, r13	; 39
 6ea:	c6 bc       	out	0x26, r12	; 38
 6ec:	89 b7       	in	r24, 0x39	; 57
 6ee:	a8 2a       	or	r10, r24
 6f0:	a9 be       	out	0x39, r10	; 57
 6f2:	1f 91       	pop	r17
 6f4:	0f 91       	pop	r16
 6f6:	ff 90       	pop	r15
 6f8:	ef 90       	pop	r14
 6fa:	df 90       	pop	r13
 6fc:	cf 90       	pop	r12
 6fe:	af 90       	pop	r10
 700:	08 95       	ret

00000702 <__vector_10>:
 }
*/
 
 /* SW PWM using the resolution way */ 
 
  ISR( TIMER0_COMP_vect ){
 702:	1f 92       	push	r1
 704:	0f 92       	push	r0
 706:	0f b6       	in	r0, 0x3f	; 63
 708:	0f 92       	push	r0
 70a:	11 24       	eor	r1, r1
 70c:	2f 93       	push	r18
 70e:	3f 93       	push	r19
 710:	4f 93       	push	r20
 712:	5f 93       	push	r21
 714:	6f 93       	push	r22
 716:	7f 93       	push	r23
 718:	8f 93       	push	r24
 71a:	9f 93       	push	r25
 71c:	af 93       	push	r26
 71e:	bf 93       	push	r27
 720:	ef 93       	push	r30
 722:	ff 93       	push	r31
	  
	  static uint8_t overflowCounter = 0 ;
	 overflowCounter++;
 724:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__data_end>
 728:	8f 5f       	subi	r24, 0xFF	; 255
 72a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__data_end>
	 
	 if (overflowCounter == g_duty)
 72e:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <g_duty>
 732:	89 13       	cpse	r24, r25
 734:	05 c0       	rjmp	.+10     	; 0x740 <__vector_10+0x3e>
	 {
		 gpioPinWrite(GPIOC, BIT0, LOW);
 736:	40 e0       	ldi	r20, 0x00	; 0
 738:	61 e0       	ldi	r22, 0x01	; 1
 73a:	82 e0       	ldi	r24, 0x02	; 2
 73c:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
	 }
	 if (overflowCounter == FULL_DUTY )
 740:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__data_end>
 744:	84 36       	cpi	r24, 0x64	; 100
 746:	39 f4       	brne	.+14     	; 0x756 <__vector_10+0x54>
	 {
		 overflowCounter = 0 ;
 748:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <__data_end>
		 gpioPinWrite(GPIOC, BIT0, HIGH);
 74c:	4f ef       	ldi	r20, 0xFF	; 255
 74e:	61 e0       	ldi	r22, 0x01	; 1
 750:	82 e0       	ldi	r24, 0x02	; 2
 752:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>

	 }
  }
 756:	ff 91       	pop	r31
 758:	ef 91       	pop	r30
 75a:	bf 91       	pop	r27
 75c:	af 91       	pop	r26
 75e:	9f 91       	pop	r25
 760:	8f 91       	pop	r24
 762:	7f 91       	pop	r23
 764:	6f 91       	pop	r22
 766:	5f 91       	pop	r21
 768:	4f 91       	pop	r20
 76a:	3f 91       	pop	r19
 76c:	2f 91       	pop	r18
 76e:	0f 90       	pop	r0
 770:	0f be       	out	0x3f, r0	; 63
 772:	0f 90       	pop	r0
 774:	1f 90       	pop	r1
 776:	18 95       	reti

00000778 <_exit>:
 778:	f8 94       	cli

0000077a <__stop_program>:
 77a:	ff cf       	rjmp	.-2      	; 0x77a <__stop_program>
