
DIO_Challenge.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005f4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  000005f4  00000668  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  0000066a  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000069c  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 000001f8  00000000  00000000  000006d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001fc0  00000000  00000000  000008d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b31  00000000  00000000  00002890  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000cd3  00000000  00000000  000033c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000003b8  00000000  00000000  00004094  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000be1  00000000  00000000  0000444c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000110d  00000000  00000000  0000502d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001b8  00000000  00000000  0000613a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 71 01 	jmp	0x2e2	; 0x2e2 <__vector_11>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e4 ef       	ldi	r30, 0xF4	; 244
  68:	f5 e0       	ldi	r31, 0x05	; 5
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a2 36       	cpi	r26, 0x62	; 98
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a2 e6       	ldi	r26, 0x62	; 98
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a2 36       	cpi	r26, 0x62	; 98
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 26 02 	call	0x44c	; 0x44c <main>
  8a:	0c 94 f8 02 	jmp	0x5f0	; 0x5f0 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <gpioPortDirection>:
				break;
			case 2:
				PORTC_DATA ^= u8_pins;
				break;
			case 3:
				PORTD_DATA ^= u8_pins;
  92:	81 30       	cpi	r24, 0x01	; 1
  94:	41 f0       	breq	.+16     	; 0xa6 <gpioPortDirection+0x14>
  96:	28 f0       	brcs	.+10     	; 0xa2 <gpioPortDirection+0x10>
  98:	82 30       	cpi	r24, 0x02	; 2
  9a:	39 f0       	breq	.+14     	; 0xaa <gpioPortDirection+0x18>
  9c:	83 30       	cpi	r24, 0x03	; 3
  9e:	39 f0       	breq	.+14     	; 0xae <gpioPortDirection+0x1c>
  a0:	08 95       	ret
  a2:	6a bb       	out	0x1a, r22	; 26
  a4:	08 95       	ret
  a6:	67 bb       	out	0x17, r22	; 23
  a8:	08 95       	ret
  aa:	64 bb       	out	0x14, r22	; 20
  ac:	08 95       	ret
  ae:	61 bb       	out	0x11, r22	; 17
  b0:	08 95       	ret

000000b2 <gpioPortWrite>:
  b2:	81 30       	cpi	r24, 0x01	; 1
  b4:	41 f0       	breq	.+16     	; 0xc6 <gpioPortWrite+0x14>
  b6:	28 f0       	brcs	.+10     	; 0xc2 <gpioPortWrite+0x10>
  b8:	82 30       	cpi	r24, 0x02	; 2
  ba:	39 f0       	breq	.+14     	; 0xca <gpioPortWrite+0x18>
  bc:	83 30       	cpi	r24, 0x03	; 3
  be:	39 f0       	breq	.+14     	; 0xce <gpioPortWrite+0x1c>
  c0:	08 95       	ret
  c2:	6b bb       	out	0x1b, r22	; 27
  c4:	08 95       	ret
  c6:	68 bb       	out	0x18, r22	; 24
  c8:	08 95       	ret
  ca:	65 bb       	out	0x15, r22	; 21
  cc:	08 95       	ret
  ce:	62 bb       	out	0x12, r22	; 18
  d0:	08 95       	ret

000000d2 <gpioPortRead>:
  d2:	81 30       	cpi	r24, 0x01	; 1
  d4:	41 f0       	breq	.+16     	; 0xe6 <gpioPortRead+0x14>
  d6:	28 f0       	brcs	.+10     	; 0xe2 <gpioPortRead+0x10>
  d8:	82 30       	cpi	r24, 0x02	; 2
  da:	39 f0       	breq	.+14     	; 0xea <gpioPortRead+0x18>
  dc:	83 30       	cpi	r24, 0x03	; 3
  de:	39 f0       	breq	.+14     	; 0xee <gpioPortRead+0x1c>
  e0:	08 c0       	rjmp	.+16     	; 0xf2 <gpioPortRead+0x20>
  e2:	89 b3       	in	r24, 0x19	; 25
  e4:	08 95       	ret
  e6:	86 b3       	in	r24, 0x16	; 22
  e8:	08 95       	ret
  ea:	83 b3       	in	r24, 0x13	; 19
  ec:	08 95       	ret
  ee:	80 b3       	in	r24, 0x10	; 16
  f0:	08 95       	ret
  f2:	80 e0       	ldi	r24, 0x00	; 0
  f4:	08 95       	ret

000000f6 <gpioPinDirection>:
  f6:	81 30       	cpi	r24, 0x01	; 1
  f8:	89 f0       	breq	.+34     	; 0x11c <gpioPinDirection+0x26>
  fa:	28 f0       	brcs	.+10     	; 0x106 <gpioPinDirection+0x10>
  fc:	82 30       	cpi	r24, 0x02	; 2
  fe:	c9 f0       	breq	.+50     	; 0x132 <gpioPinDirection+0x3c>
 100:	83 30       	cpi	r24, 0x03	; 3
 102:	11 f1       	breq	.+68     	; 0x148 <gpioPinDirection+0x52>
 104:	08 95       	ret
 106:	41 11       	cpse	r20, r1
 108:	05 c0       	rjmp	.+10     	; 0x114 <gpioPinDirection+0x1e>
 10a:	8a b3       	in	r24, 0x1a	; 26
 10c:	60 95       	com	r22
 10e:	68 23       	and	r22, r24
 110:	6a bb       	out	0x1a, r22	; 26
 112:	08 95       	ret
 114:	8a b3       	in	r24, 0x1a	; 26
 116:	68 2b       	or	r22, r24
 118:	6a bb       	out	0x1a, r22	; 26
 11a:	08 95       	ret
 11c:	41 11       	cpse	r20, r1
 11e:	05 c0       	rjmp	.+10     	; 0x12a <gpioPinDirection+0x34>
 120:	87 b3       	in	r24, 0x17	; 23
 122:	60 95       	com	r22
 124:	68 23       	and	r22, r24
 126:	67 bb       	out	0x17, r22	; 23
 128:	08 95       	ret
 12a:	87 b3       	in	r24, 0x17	; 23
 12c:	68 2b       	or	r22, r24
 12e:	67 bb       	out	0x17, r22	; 23
 130:	08 95       	ret
 132:	41 11       	cpse	r20, r1
 134:	05 c0       	rjmp	.+10     	; 0x140 <gpioPinDirection+0x4a>
 136:	84 b3       	in	r24, 0x14	; 20
 138:	60 95       	com	r22
 13a:	68 23       	and	r22, r24
 13c:	64 bb       	out	0x14, r22	; 20
 13e:	08 95       	ret
 140:	84 b3       	in	r24, 0x14	; 20
 142:	68 2b       	or	r22, r24
 144:	64 bb       	out	0x14, r22	; 20
 146:	08 95       	ret
 148:	41 11       	cpse	r20, r1
 14a:	05 c0       	rjmp	.+10     	; 0x156 <gpioPinDirection+0x60>
 14c:	81 b3       	in	r24, 0x11	; 17
 14e:	60 95       	com	r22
 150:	68 23       	and	r22, r24
 152:	61 bb       	out	0x11, r22	; 17
 154:	08 95       	ret
 156:	81 b3       	in	r24, 0x11	; 17
 158:	68 2b       	or	r22, r24
 15a:	61 bb       	out	0x11, r22	; 17
 15c:	08 95       	ret

0000015e <gpioPinWrite>:
 15e:	81 30       	cpi	r24, 0x01	; 1
 160:	89 f0       	breq	.+34     	; 0x184 <gpioPinWrite+0x26>
 162:	28 f0       	brcs	.+10     	; 0x16e <gpioPinWrite+0x10>
 164:	82 30       	cpi	r24, 0x02	; 2
 166:	c9 f0       	breq	.+50     	; 0x19a <gpioPinWrite+0x3c>
 168:	83 30       	cpi	r24, 0x03	; 3
 16a:	11 f1       	breq	.+68     	; 0x1b0 <gpioPinWrite+0x52>
 16c:	08 95       	ret
 16e:	8b b3       	in	r24, 0x1b	; 27
 170:	96 2f       	mov	r25, r22
 172:	90 95       	com	r25
 174:	89 23       	and	r24, r25
 176:	8b bb       	out	0x1b, r24	; 27
 178:	44 23       	and	r20, r20
 17a:	21 f1       	breq	.+72     	; 0x1c4 <gpioPinWrite+0x66>
 17c:	8b b3       	in	r24, 0x1b	; 27
 17e:	68 2b       	or	r22, r24
 180:	6b bb       	out	0x1b, r22	; 27
 182:	08 95       	ret
 184:	88 b3       	in	r24, 0x18	; 24
 186:	96 2f       	mov	r25, r22
 188:	90 95       	com	r25
 18a:	89 23       	and	r24, r25
 18c:	88 bb       	out	0x18, r24	; 24
 18e:	44 23       	and	r20, r20
 190:	c9 f0       	breq	.+50     	; 0x1c4 <gpioPinWrite+0x66>
 192:	88 b3       	in	r24, 0x18	; 24
 194:	68 2b       	or	r22, r24
 196:	68 bb       	out	0x18, r22	; 24
 198:	08 95       	ret
 19a:	85 b3       	in	r24, 0x15	; 21
 19c:	96 2f       	mov	r25, r22
 19e:	90 95       	com	r25
 1a0:	89 23       	and	r24, r25
 1a2:	85 bb       	out	0x15, r24	; 21
 1a4:	44 23       	and	r20, r20
 1a6:	71 f0       	breq	.+28     	; 0x1c4 <gpioPinWrite+0x66>
 1a8:	85 b3       	in	r24, 0x15	; 21
 1aa:	68 2b       	or	r22, r24
 1ac:	65 bb       	out	0x15, r22	; 21
 1ae:	08 95       	ret
 1b0:	82 b3       	in	r24, 0x12	; 18
 1b2:	96 2f       	mov	r25, r22
 1b4:	90 95       	com	r25
 1b6:	89 23       	and	r24, r25
 1b8:	82 bb       	out	0x12, r24	; 18
 1ba:	44 23       	and	r20, r20
 1bc:	19 f0       	breq	.+6      	; 0x1c4 <gpioPinWrite+0x66>
 1be:	82 b3       	in	r24, 0x12	; 18
 1c0:	68 2b       	or	r22, r24
 1c2:	62 bb       	out	0x12, r22	; 18
 1c4:	08 95       	ret

000001c6 <gpioPinRead>:
 */
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin){
	
			uint8_t	u8_value = 0;
			
			switch(u8_port){
 1c6:	81 30       	cpi	r24, 0x01	; 1
 1c8:	49 f0       	breq	.+18     	; 0x1dc <gpioPinRead+0x16>
 1ca:	28 f0       	brcs	.+10     	; 0x1d6 <gpioPinRead+0x10>
 1cc:	82 30       	cpi	r24, 0x02	; 2
 1ce:	49 f0       	breq	.+18     	; 0x1e2 <gpioPinRead+0x1c>
 1d0:	83 30       	cpi	r24, 0x03	; 3
 1d2:	51 f0       	breq	.+20     	; 0x1e8 <gpioPinRead+0x22>
 1d4:	0c c0       	rjmp	.+24     	; 0x1ee <gpioPinRead+0x28>
				
				case 0:
				u8_value =	 (PORTA_PIN & u8_pin ) ;
 1d6:	89 b3       	in	r24, 0x19	; 25
 1d8:	68 23       	and	r22, r24
						break;
 1da:	0a c0       	rjmp	.+20     	; 0x1f0 <gpioPinRead+0x2a>
				case 1:
				u8_value =	 (PORTB_PIN & u8_pin ) ;
 1dc:	86 b3       	in	r24, 0x16	; 22
 1de:	68 23       	and	r22, r24
						break;
 1e0:	07 c0       	rjmp	.+14     	; 0x1f0 <gpioPinRead+0x2a>
				case 2:
				u8_value =	 (PORTC_PIN & u8_pin ) ;
 1e2:	83 b3       	in	r24, 0x13	; 19
 1e4:	68 23       	and	r22, r24
						break;
 1e6:	04 c0       	rjmp	.+8      	; 0x1f0 <gpioPinRead+0x2a>
				case 3:
				u8_value =	(PORTD_PIN & u8_pin ) ;
 1e8:	80 b3       	in	r24, 0x10	; 16
 1ea:	68 23       	and	r22, r24
						break;
 1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <gpioPinRead+0x2a>
 * 				- BIT7
 * @return
 */
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin){
	
			uint8_t	u8_value = 0;
 1ee:	60 e0       	ldi	r22, 0x00	; 0
 1f0:	81 e0       	ldi	r24, 0x01	; 1
 1f2:	61 11       	cpse	r22, r1
 1f4:	01 c0       	rjmp	.+2      	; 0x1f8 <gpioPinRead+0x32>
 1f6:	80 e0       	ldi	r24, 0x00	; 0
			{
				return 1;
			} else {
				return 0;
			}
}
 1f8:	08 95       	ret

000001fa <Led_Init>:

#include "led.h"

void Led_Init(En_LedNumber_t en_led_id){
	
	switch(en_led_id){
 1fa:	81 30       	cpi	r24, 0x01	; 1
 1fc:	89 f0       	breq	.+34     	; 0x220 <Led_Init+0x26>
 1fe:	28 f0       	brcs	.+10     	; 0x20a <Led_Init+0x10>
 200:	82 30       	cpi	r24, 0x02	; 2
 202:	c9 f0       	breq	.+50     	; 0x236 <Led_Init+0x3c>
 204:	83 30       	cpi	r24, 0x03	; 3
 206:	11 f1       	breq	.+68     	; 0x24c <Led_Init+0x52>
 208:	08 95       	ret
		
		case LED_0:
				gpioPinDirection( LED_0_GPIO, LED_0_BIT, OUTPUT );
 20a:	4f ef       	ldi	r20, 0xFF	; 255
 20c:	60 e1       	ldi	r22, 0x10	; 16
 20e:	81 e0       	ldi	r24, 0x01	; 1
 210:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				gpioPinWrite(LED_0_GPIO, LED_0_BIT, LOW);
 214:	40 e0       	ldi	r20, 0x00	; 0
 216:	60 e1       	ldi	r22, 0x10	; 16
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
					break;
 21e:	08 95       	ret
		case LED_1:
				gpioPinDirection( LED_1_GPIO, LED_1_BIT, OUTPUT );
 220:	4f ef       	ldi	r20, 0xFF	; 255
 222:	60 e2       	ldi	r22, 0x20	; 32
 224:	81 e0       	ldi	r24, 0x01	; 1
 226:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				gpioPinWrite(LED_1_GPIO, LED_1_BIT, LOW);		
 22a:	40 e0       	ldi	r20, 0x00	; 0
 22c:	60 e2       	ldi	r22, 0x20	; 32
 22e:	81 e0       	ldi	r24, 0x01	; 1
 230:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
					break;
 234:	08 95       	ret
		case LED_2:
				gpioPinDirection( LED_2_GPIO, LED_2_BIT, OUTPUT );
 236:	4f ef       	ldi	r20, 0xFF	; 255
 238:	60 e4       	ldi	r22, 0x40	; 64
 23a:	81 e0       	ldi	r24, 0x01	; 1
 23c:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				gpioPinWrite(LED_2_GPIO, LED_2_BIT, LOW);		
 240:	40 e0       	ldi	r20, 0x00	; 0
 242:	60 e4       	ldi	r22, 0x40	; 64
 244:	81 e0       	ldi	r24, 0x01	; 1
 246:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
					break;
 24a:	08 95       	ret
		case LED_3:
				gpioPinDirection( LED_3_GPIO, LED_3_BIT, OUTPUT );
 24c:	4f ef       	ldi	r20, 0xFF	; 255
 24e:	60 e8       	ldi	r22, 0x80	; 128
 250:	81 e0       	ldi	r24, 0x01	; 1
 252:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				gpioPinWrite(LED_3_GPIO, LED_3_BIT, LOW);		
 256:	40 e0       	ldi	r20, 0x00	; 0
 258:	60 e8       	ldi	r22, 0x80	; 128
 25a:	81 e0       	ldi	r24, 0x01	; 1
 25c:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
 260:	08 95       	ret

00000262 <Led_On>:
 * 				  one of the enum (En_LedNumber_t) parameters
 *
 */
void Led_On(En_LedNumber_t en_led_id){
	
	switch(en_led_id){
 262:	81 30       	cpi	r24, 0x01	; 1
 264:	61 f0       	breq	.+24     	; 0x27e <Led_On+0x1c>
 266:	28 f0       	brcs	.+10     	; 0x272 <Led_On+0x10>
 268:	82 30       	cpi	r24, 0x02	; 2
 26a:	79 f0       	breq	.+30     	; 0x28a <Led_On+0x28>
 26c:	83 30       	cpi	r24, 0x03	; 3
 26e:	99 f0       	breq	.+38     	; 0x296 <Led_On+0x34>
 270:	08 95       	ret
		
		case LED_0:
			gpioPinWrite(LED_0_GPIO, LED_0_BIT, HIGH);
 272:	4f ef       	ldi	r20, 0xFF	; 255
 274:	60 e1       	ldi	r22, 0x10	; 16
 276:	81 e0       	ldi	r24, 0x01	; 1
 278:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
			break;
 27c:	08 95       	ret
		case LED_1:
			gpioPinWrite(LED_1_GPIO, LED_1_BIT, HIGH);
 27e:	4f ef       	ldi	r20, 0xFF	; 255
 280:	60 e2       	ldi	r22, 0x20	; 32
 282:	81 e0       	ldi	r24, 0x01	; 1
 284:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
			break;
 288:	08 95       	ret
		case LED_2:
			gpioPinWrite(LED_2_GPIO, LED_2_BIT, HIGH);
 28a:	4f ef       	ldi	r20, 0xFF	; 255
 28c:	60 e4       	ldi	r22, 0x40	; 64
 28e:	81 e0       	ldi	r24, 0x01	; 1
 290:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
			break;
 294:	08 95       	ret
		case LED_3:
			gpioPinWrite(LED_3_GPIO, LED_3_BIT, HIGH);
 296:	4f ef       	ldi	r20, 0xFF	; 255
 298:	60 e8       	ldi	r22, 0x80	; 128
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
 2a0:	08 95       	ret

000002a2 <Led_Off>:
 * 				  one of the enum (En_LedNumber_t) parameters
 *
 */
void Led_Off(En_LedNumber_t en_led_id){
	
	switch(en_led_id){
 2a2:	81 30       	cpi	r24, 0x01	; 1
 2a4:	61 f0       	breq	.+24     	; 0x2be <Led_Off+0x1c>
 2a6:	28 f0       	brcs	.+10     	; 0x2b2 <Led_Off+0x10>
 2a8:	82 30       	cpi	r24, 0x02	; 2
 2aa:	79 f0       	breq	.+30     	; 0x2ca <Led_Off+0x28>
 2ac:	83 30       	cpi	r24, 0x03	; 3
 2ae:	99 f0       	breq	.+38     	; 0x2d6 <Led_Off+0x34>
 2b0:	08 95       	ret
		
		case LED_0:
				gpioPinWrite(LED_0_GPIO, LED_0_BIT, LOW);
 2b2:	40 e0       	ldi	r20, 0x00	; 0
 2b4:	60 e1       	ldi	r22, 0x10	; 16
 2b6:	81 e0       	ldi	r24, 0x01	; 1
 2b8:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
				break;
 2bc:	08 95       	ret
		case LED_1:
				gpioPinWrite(LED_1_GPIO, LED_1_BIT, LOW);
 2be:	40 e0       	ldi	r20, 0x00	; 0
 2c0:	60 e2       	ldi	r22, 0x20	; 32
 2c2:	81 e0       	ldi	r24, 0x01	; 1
 2c4:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
				break;
 2c8:	08 95       	ret
		case LED_2:
				gpioPinWrite(LED_2_GPIO, LED_2_BIT, LOW);
 2ca:	40 e0       	ldi	r20, 0x00	; 0
 2cc:	60 e4       	ldi	r22, 0x40	; 64
 2ce:	81 e0       	ldi	r24, 0x01	; 1
 2d0:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
				break;
 2d4:	08 95       	ret
		case LED_3:
				gpioPinWrite(LED_3_GPIO, LED_3_BIT, LOW);
 2d6:	40 e0       	ldi	r20, 0x00	; 0
 2d8:	60 e8       	ldi	r22, 0x80	; 128
 2da:	81 e0       	ldi	r24, 0x01	; 1
 2dc:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
 2e0:	08 95       	ret

000002e2 <__vector_11>:

__attribute__((signal,__INTR_ATTRS));
void __vector_11 (void)
{

	PORTC_DATA |=0XFF;
 2e2:	85 b3       	in	r24, 0x15	; 21
 2e4:	8f ef       	ldi	r24, 0xFF	; 255
 2e6:	85 bb       	out	0x15, r24	; 21
 2e8:	08 95       	ret

000002ea <REQ1_Start>:
 * 
 *
 */
void REQ1_Start(void)
{
	sevenSegInit(SEG_0);
 2ea:	80 e0       	ldi	r24, 0x00	; 0
 2ec:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <sevenSegInit>
	sevenSegInit(SEG_1);
 2f0:	81 e0       	ldi	r24, 0x01	; 1
 2f2:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <sevenSegInit>
		for ( sevSegNumber = 0; sevSegNumber < 100 ; sevSegNumber++ )
		{
			for (int cnt=0; cnt<10; cnt++)
			{
				sevenSegEnable(SEG_0);
				sevenSegWrite(SEG_0, sevSegNumber / 10 );
 2f6:	0f 2e       	mov	r0, r31
 2f8:	fd ec       	ldi	r31, 0xCD	; 205
 2fa:	ef 2e       	mov	r14, r31
 2fc:	f0 2d       	mov	r31, r0
{
	sevenSegInit(SEG_0);
	sevenSegInit(SEG_1);
	uint8_t sevSegNumber = 0;
	while(1){
		for ( sevSegNumber = 0; sevSegNumber < 100 ; sevSegNumber++ )
 2fe:	f1 2c       	mov	r15, r1
 300:	22 c0       	rjmp	.+68     	; 0x346 <REQ1_Start+0x5c>
		{
			for (int cnt=0; cnt<10; cnt++)
			{
				sevenSegEnable(SEG_0);
 302:	80 e0       	ldi	r24, 0x00	; 0
 304:	0e 94 84 02 	call	0x508	; 0x508 <sevenSegEnable>
				sevenSegWrite(SEG_0, sevSegNumber / 10 );
 308:	61 2f       	mov	r22, r17
 30a:	80 e0       	ldi	r24, 0x00	; 0
 30c:	0e 94 a6 02 	call	0x54c	; 0x54c <sevenSegWrite>
				//softwareDelayMs(50);
				timer0DelayMs(20);
 310:	84 e1       	ldi	r24, 0x14	; 20
 312:	90 e0       	ldi	r25, 0x00	; 0
 314:	0e 94 de 02 	call	0x5bc	; 0x5bc <timer0DelayMs>
				sevenSegDisable(SEG_0);
 318:	80 e0       	ldi	r24, 0x00	; 0
 31a:	0e 94 95 02 	call	0x52a	; 0x52a <sevenSegDisable>
				
				
				sevenSegEnable(SEG_1);
 31e:	81 e0       	ldi	r24, 0x01	; 1
 320:	0e 94 84 02 	call	0x508	; 0x508 <sevenSegEnable>
				sevenSegWrite(SEG_1, sevSegNumber % 10 );
 324:	60 2f       	mov	r22, r16
 326:	81 e0       	ldi	r24, 0x01	; 1
 328:	0e 94 a6 02 	call	0x54c	; 0x54c <sevenSegWrite>
				//softwareDelayMs(50);
				timer0DelayMs(20);
 32c:	84 e1       	ldi	r24, 0x14	; 20
 32e:	90 e0       	ldi	r25, 0x00	; 0
 330:	0e 94 de 02 	call	0x5bc	; 0x5bc <timer0DelayMs>
				sevenSegDisable(SEG_1);
 334:	81 e0       	ldi	r24, 0x01	; 1
 336:	0e 94 95 02 	call	0x52a	; 0x52a <sevenSegDisable>
 33a:	21 97       	sbiw	r28, 0x01	; 1
	sevenSegInit(SEG_1);
	uint8_t sevSegNumber = 0;
	while(1){
		for ( sevSegNumber = 0; sevSegNumber < 100 ; sevSegNumber++ )
		{
			for (int cnt=0; cnt<10; cnt++)
 33c:	11 f7       	brne	.-60     	; 0x302 <REQ1_Start+0x18>
{
	sevenSegInit(SEG_0);
	sevenSegInit(SEG_1);
	uint8_t sevSegNumber = 0;
	while(1){
		for ( sevSegNumber = 0; sevSegNumber < 100 ; sevSegNumber++ )
 33e:	f3 94       	inc	r15
 340:	84 e6       	ldi	r24, 0x64	; 100
 342:	f8 16       	cp	r15, r24
 344:	e1 f2       	breq	.-72     	; 0x2fe <REQ1_Start+0x14>
		{
			for (int cnt=0; cnt<10; cnt++)
			{
				sevenSegEnable(SEG_0);
				sevenSegWrite(SEG_0, sevSegNumber / 10 );
 346:	fe 9c       	mul	r15, r14
 348:	11 2d       	mov	r17, r1
 34a:	11 24       	eor	r1, r1
 34c:	16 95       	lsr	r17
 34e:	16 95       	lsr	r17
 350:	16 95       	lsr	r17
				timer0DelayMs(20);
				sevenSegDisable(SEG_0);
				
				
				sevenSegEnable(SEG_1);
				sevenSegWrite(SEG_1, sevSegNumber % 10 );
 352:	91 2f       	mov	r25, r17
 354:	99 0f       	add	r25, r25
 356:	89 2f       	mov	r24, r25
 358:	88 0f       	add	r24, r24
 35a:	88 0f       	add	r24, r24
 35c:	89 0f       	add	r24, r25
 35e:	0f 2d       	mov	r16, r15
 360:	08 1b       	sub	r16, r24
 362:	ca e0       	ldi	r28, 0x0A	; 10
 364:	d0 e0       	ldi	r29, 0x00	; 0
 366:	cd cf       	rjmp	.-102    	; 0x302 <REQ1_Start+0x18>

00000368 <REQ2_Start>:
		second presses is less than 1s, the LED 1 will be on for 2 seconds then off
		If the time between them is more than 1s then the led will be turned off after 1s
 */
void REQ2_Start(void)
{
	Led_Init(LED_1);
 368:	81 e0       	ldi	r24, 0x01	; 1
 36a:	0e 94 fd 00 	call	0x1fa	; 0x1fa <Led_Init>
	uint8_t pressCounts = 0 ;
	uint8_t internalPress = 0;
	
	while(1){
		pressCounts = 0 ;
		internalPress = 0;
 36e:	00 e0       	ldi	r16, 0x00	; 0
		if (pushButtonGetStatus(BTN_1) == Prepressed)
 370:	81 e0       	ldi	r24, 0x01	; 1
 372:	0e 94 4e 02 	call	0x49c	; 0x49c <pushButtonGetStatus>
 376:	81 30       	cpi	r24, 0x01	; 1
 378:	29 f5       	brne	.+74     	; 0x3c4 <REQ2_Start+0x5c>
		{
			//softwareDelayMs(20);
			timer0DelayMs(20);
 37a:	84 e1       	ldi	r24, 0x14	; 20
 37c:	90 e0       	ldi	r25, 0x00	; 0
 37e:	0e 94 de 02 	call	0x5bc	; 0x5bc <timer0DelayMs>
			if (pushButtonGetStatus(BTN_1) == Prepressed)
 382:	81 e0       	ldi	r24, 0x01	; 1
 384:	0e 94 4e 02 	call	0x49c	; 0x49c <pushButtonGetStatus>
 388:	81 30       	cpi	r24, 0x01	; 1
 38a:	c1 f4       	brne	.+48     	; 0x3bc <REQ2_Start+0x54>
			{
				if (pressCounts == 0)
				{
					pressCounts++;
					Led_On(LED_1);
 38c:	0e 94 31 01 	call	0x262	; 0x262 <Led_On>
 390:	c5 e0       	ldi	r28, 0x05	; 5
 392:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t pressCounts = 0 ;
	uint8_t internalPress = 0;
	
	while(1){
		pressCounts = 0 ;
		internalPress = 0;
 394:	10 2f       	mov	r17, r16
					/* break the blocking time to be able to listen */
					
							for (int i = 0; i < 5; i++){
								
								//	softwareDelayMs(200);
								timer0DelayMs(200);
 396:	88 ec       	ldi	r24, 0xC8	; 200
 398:	90 e0       	ldi	r25, 0x00	; 0
 39a:	0e 94 de 02 	call	0x5bc	; 0x5bc <timer0DelayMs>

								if (pushButtonGetStatus(BTN_1) == Prepressed){
 39e:	81 e0       	ldi	r24, 0x01	; 1
 3a0:	0e 94 4e 02 	call	0x49c	; 0x49c <pushButtonGetStatus>
 3a4:	81 30       	cpi	r24, 0x01	; 1
 3a6:	09 f4       	brne	.+2      	; 0x3aa <REQ2_Start+0x42>
										internalPress = 1;
 3a8:	11 e0       	ldi	r17, 0x01	; 1
 3aa:	21 97       	sbiw	r28, 0x01	; 1
				{
					pressCounts++;
					Led_On(LED_1);
					/* break the blocking time to be able to listen */
					
							for (int i = 0; i < 5; i++){
 3ac:	a1 f7       	brne	.-24     	; 0x396 <REQ2_Start+0x2e>
								if (pushButtonGetStatus(BTN_1) == Prepressed){
										internalPress = 1;
											}
										  }
					
											if (internalPress == 0)
 3ae:	11 23       	and	r17, r17
 3b0:	f9 f2       	breq	.-66     	; 0x370 <REQ2_Start+0x8>
												{
													pressCounts = 0;
												}else {
														pressCounts++;
														//softwareDelayMs(1000);
														timer0DelayMs(1000);
 3b2:	88 ee       	ldi	r24, 0xE8	; 232
 3b4:	93 e0       	ldi	r25, 0x03	; 3
 3b6:	0e 94 de 02 	call	0x5bc	; 0x5bc <timer0DelayMs>
 3ba:	da cf       	rjmp	.-76     	; 0x370 <REQ2_Start+0x8>
																		}
					}
				} else {
				Led_Off(LED_1);
 3bc:	81 e0       	ldi	r24, 0x01	; 1
 3be:	0e 94 51 01 	call	0x2a2	; 0x2a2 <Led_Off>
 3c2:	d6 cf       	rjmp	.-84     	; 0x370 <REQ2_Start+0x8>
			}
			} else {
			Led_Off(LED_1);
 3c4:	81 e0       	ldi	r24, 0x01	; 1
 3c6:	0e 94 51 01 	call	0x2a2	; 0x2a2 <Led_Off>
 3ca:	d2 cf       	rjmp	.-92     	; 0x370 <REQ2_Start+0x8>

000003cc <Go_State>:
	
}

void Go_State(void)
{
	Led_On(LED_1);
 3cc:	81 e0       	ldi	r24, 0x01	; 1
 3ce:	0e 94 31 01 	call	0x262	; 0x262 <Led_On>
	//softwareDelayMs(1000);
	timer0DelayMs(1000);
 3d2:	88 ee       	ldi	r24, 0xE8	; 232
 3d4:	93 e0       	ldi	r25, 0x03	; 3
 3d6:	0e 94 de 02 	call	0x5bc	; 0x5bc <timer0DelayMs>
	Led_Off(LED_1);
 3da:	81 e0       	ldi	r24, 0x01	; 1
 3dc:	0e 94 51 01 	call	0x2a2	; 0x2a2 <Led_Off>
 3e0:	08 95       	ret

000003e2 <Ready_State>:



void Ready_State(void)
{
	Led_On(LED_2);
 3e2:	82 e0       	ldi	r24, 0x02	; 2
 3e4:	0e 94 31 01 	call	0x262	; 0x262 <Led_On>
	//softwareDelayMs(1000);
	timer0DelayMs(1000);
 3e8:	88 ee       	ldi	r24, 0xE8	; 232
 3ea:	93 e0       	ldi	r25, 0x03	; 3
 3ec:	0e 94 de 02 	call	0x5bc	; 0x5bc <timer0DelayMs>

	Led_Off(LED_2);
 3f0:	82 e0       	ldi	r24, 0x02	; 2
 3f2:	0e 94 51 01 	call	0x2a2	; 0x2a2 <Led_Off>
 3f6:	08 95       	ret

000003f8 <Stop_State>:
}


void Stop_State(void)
{
	Led_On(LED_3);
 3f8:	83 e0       	ldi	r24, 0x03	; 3
 3fa:	0e 94 31 01 	call	0x262	; 0x262 <Led_On>
	//softwareDelayMs(1000);
	timer0DelayMs(1000);
 3fe:	88 ee       	ldi	r24, 0xE8	; 232
 400:	93 e0       	ldi	r25, 0x03	; 3
 402:	0e 94 de 02 	call	0x5bc	; 0x5bc <timer0DelayMs>

	Led_Off(LED_3);
 406:	83 e0       	ldi	r24, 0x03	; 3
 408:	0e 94 51 01 	call	0x2a2	; 0x2a2 <Led_Off>
 40c:	08 95       	ret

0000040e <REQ3_Start>:
 *
 */

void REQ3_Start(void)
{
	Led_Init(LED_1);
 40e:	81 e0       	ldi	r24, 0x01	; 1
 410:	0e 94 fd 00 	call	0x1fa	; 0x1fa <Led_Init>
	Led_Init(LED_2);
 414:	82 e0       	ldi	r24, 0x02	; 2
 416:	0e 94 fd 00 	call	0x1fa	; 0x1fa <Led_Init>
	Led_Init(LED_3);
 41a:	83 e0       	ldi	r24, 0x03	; 3
 41c:	0e 94 fd 00 	call	0x1fa	; 0x1fa <Led_Init>
	
	uint8_t State = 0;
 420:	80 e0       	ldi	r24, 0x00	; 0
			Go_State();
			State = 1;
			break;
			case 1:
			Ready_State();
			State = 2;
 422:	12 e0       	ldi	r17, 0x02	; 2
	for (;;)
	{
		switch(State){
			case 0:
			Go_State();
			State = 1;
 424:	d1 e0       	ldi	r29, 0x01	; 1
			Ready_State();
			State = 2;
			break;
			case 2:
			Stop_State();
			State = 0;
 426:	c0 e0       	ldi	r28, 0x00	; 0
	Led_Init(LED_3);
	
	uint8_t State = 0;
	for (;;)
	{
		switch(State){
 428:	81 30       	cpi	r24, 0x01	; 1
 42a:	41 f0       	breq	.+16     	; 0x43c <REQ3_Start+0x2e>
 42c:	18 f0       	brcs	.+6      	; 0x434 <REQ3_Start+0x26>
 42e:	82 30       	cpi	r24, 0x02	; 2
 430:	49 f0       	breq	.+18     	; 0x444 <REQ3_Start+0x36>
 432:	fa cf       	rjmp	.-12     	; 0x428 <REQ3_Start+0x1a>
			case 0:
			Go_State();
 434:	0e 94 e6 01 	call	0x3cc	; 0x3cc <Go_State>
			State = 1;
 438:	8d 2f       	mov	r24, r29
			break;
 43a:	f6 cf       	rjmp	.-20     	; 0x428 <REQ3_Start+0x1a>
			case 1:
			Ready_State();
 43c:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <Ready_State>
			State = 2;
 440:	81 2f       	mov	r24, r17
			break;
 442:	f2 cf       	rjmp	.-28     	; 0x428 <REQ3_Start+0x1a>
			case 2:
			Stop_State();
 444:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <Stop_State>
			State = 0;
 448:	8c 2f       	mov	r24, r28
			break;
 44a:	ee cf       	rjmp	.-36     	; 0x428 <REQ3_Start+0x1a>

0000044c <main>:
	
}

int main(void)
{ 
		PORTC_DIR = 0XFF;
 44c:	8f ef       	ldi	r24, 0xFF	; 255
 44e:	84 bb       	out	0x14, r24	; 20
		
	timer0Init(T0_NORMAL_MODE, T0_OC0_DIS, T0_PRESCALER_64, 0,0 ,T0_INTERRUPT_NORMAL);
 450:	ee 24       	eor	r14, r14
 452:	e3 94       	inc	r14
 454:	00 e0       	ldi	r16, 0x00	; 0
 456:	20 e0       	ldi	r18, 0x00	; 0
 458:	43 e0       	ldi	r20, 0x03	; 3
 45a:	60 e0       	ldi	r22, 0x00	; 0
 45c:	80 e0       	ldi	r24, 0x00	; 0
 45e:	0e 94 c2 02 	call	0x584	; 0x584 <timer0Init>
	//timer1Init(T1_NORMAL_MODE, T1_OC1_DIS, T1_PRESCALER_64, 0,0,0,0 ,T1_POLLING);
     SREG |= (1<<7); 
 462:	8f b7       	in	r24, 0x3f	; 63
 464:	80 68       	ori	r24, 0x80	; 128
 466:	8f bf       	out	0x3f, r24	; 63
	/* dual inline package switch to choose the requirement to show */
	
	uint8_t REQ_Select = 0;
	
	gpioPinDirection(GPIOA, (BIT5 | BIT6 | BIT7), INPUT);
 468:	40 e0       	ldi	r20, 0x00	; 0
 46a:	60 ee       	ldi	r22, 0xE0	; 224
 46c:	80 e0       	ldi	r24, 0x00	; 0
 46e:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
	gpioPortWrite(GPIOA, (BIT5 | BIT6 | BIT7));
 472:	60 ee       	ldi	r22, 0xE0	; 224
 474:	80 e0       	ldi	r24, 0x00	; 0
 476:	0e 94 59 00 	call	0xb2	; 0xb2 <gpioPortWrite>
	
	REQ_Select = gpioPortRead(GPIOA);
 47a:	80 e0       	ldi	r24, 0x00	; 0
 47c:	0e 94 69 00 	call	0xd2	; 0xd2 <gpioPortRead>
	
	switch(REQ_Select)
 480:	80 3a       	cpi	r24, 0xA0	; 160
 482:	39 f0       	breq	.+14     	; 0x492 <main+0x46>
 484:	80 3c       	cpi	r24, 0xC0	; 192
 486:	19 f0       	breq	.+6      	; 0x48e <main+0x42>
 488:	80 36       	cpi	r24, 0x60	; 96
 48a:	29 f0       	breq	.+10     	; 0x496 <main+0x4a>
 48c:	06 c0       	rjmp	.+12     	; 0x49a <main+0x4e>
	{
		case 192: //110
			REQ1_Start();
 48e:	0e 94 75 01 	call	0x2ea	; 0x2ea <REQ1_Start>
			break;
		case 160: //101
			REQ2_Start();
 492:	0e 94 b4 01 	call	0x368	; 0x368 <REQ2_Start>
			break;
		case 96:// 011
			REQ3_Start();
 496:	0e 94 07 02 	call	0x40e	; 0x40e <REQ3_Start>
 49a:	ff cf       	rjmp	.-2      	; 0x49a <main+0x4e>

0000049c <pushButtonGetStatus>:
 */
En_buttonStatus_t pushButtonGetStatus(En_buttonId_t en_butotn_id){
		
	uint8_t current_state = 0;
		
	switch(en_butotn_id){
 49c:	81 30       	cpi	r24, 0x01	; 1
 49e:	59 f0       	breq	.+22     	; 0x4b6 <pushButtonGetStatus+0x1a>
 4a0:	28 f0       	brcs	.+10     	; 0x4ac <pushButtonGetStatus+0x10>
 4a2:	82 30       	cpi	r24, 0x02	; 2
 4a4:	69 f0       	breq	.+26     	; 0x4c0 <pushButtonGetStatus+0x24>
 4a6:	83 30       	cpi	r24, 0x03	; 3
 4a8:	81 f0       	breq	.+32     	; 0x4ca <pushButtonGetStatus+0x2e>
 4aa:	14 c0       	rjmp	.+40     	; 0x4d4 <pushButtonGetStatus+0x38>
		
		case BTN_0:
				current_state = gpioPinRead( BTN_0_GPIO, BTN_0_BIT );
 4ac:	60 e1       	ldi	r22, 0x10	; 16
 4ae:	82 e0       	ldi	r24, 0x02	; 2
 4b0:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <gpioPinRead>
				break;
 4b4:	08 95       	ret
		case BTN_1:
				current_state =	gpioPinRead( BTN_1_GPIO, BTN_1_BIT );
 4b6:	64 e0       	ldi	r22, 0x04	; 4
 4b8:	81 e0       	ldi	r24, 0x01	; 1
 4ba:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <gpioPinRead>
				break;
 4be:	08 95       	ret
		case BTN_2:
				current_state = gpioPinRead( BTN_2_GPIO, BTN_2_BIT );
 4c0:	64 e0       	ldi	r22, 0x04	; 4
 4c2:	80 e0       	ldi	r24, 0x00	; 0
 4c4:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <gpioPinRead>
				break;
 4c8:	08 95       	ret
		case BTN_3:
				current_state = gpioPinRead( BTN_3_GPIO, BTN_3_BIT );
 4ca:	68 e0       	ldi	r22, 0x08	; 8
 4cc:	80 e0       	ldi	r24, 0x00	; 0
 4ce:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <gpioPinRead>
				break;
 4d2:	08 95       	ret
 * 				in the update function
 *
 */
En_buttonStatus_t pushButtonGetStatus(En_buttonId_t en_butotn_id){
		
	uint8_t current_state = 0;
 4d4:	80 e0       	ldi	r24, 0x00	; 0
				current_state = gpioPinRead( BTN_3_GPIO, BTN_3_BIT );
				break;
		default:break;
	}
	return current_state;
 4d6:	08 95       	ret

000004d8 <sevenSegInit>:

/**
 * Description:  initialize seven segment data port as output
 * @param a_segment_id
 */
void sevenSegInit(En_SevenSegId_t a_segment_id){
 4d8:	cf 93       	push	r28
 4da:	c8 2f       	mov	r28, r24
	
	gpioPortDirection(SEG_BCD_GPIO, OUTPUT);
 4dc:	6f ef       	ldi	r22, 0xFF	; 255
 4de:	81 e0       	ldi	r24, 0x01	; 1
 4e0:	0e 94 49 00 	call	0x92	; 0x92 <gpioPortDirection>
	
	switch(a_segment_id){
 4e4:	cc 23       	and	r28, r28
 4e6:	19 f0       	breq	.+6      	; 0x4ee <sevenSegInit+0x16>
 4e8:	c1 30       	cpi	r28, 0x01	; 1
 4ea:	39 f0       	breq	.+14     	; 0x4fa <sevenSegInit+0x22>
 4ec:	0b c0       	rjmp	.+22     	; 0x504 <sevenSegInit+0x2c>
		
		case SEG_0:
				gpioPinDirection(SEG_EN1_GPIO, SEG_EN1_BIT, OUTPUT);
 4ee:	4f ef       	ldi	r20, 0xFF	; 255
 4f0:	64 e0       	ldi	r22, 0x04	; 4
 4f2:	83 e0       	ldi	r24, 0x03	; 3
 4f4:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
				break;
 4f8:	05 c0       	rjmp	.+10     	; 0x504 <sevenSegInit+0x2c>
				
		case SEG_1:
				gpioPinDirection(SEG_EN2_GPIO, SEG_EN2_BIT, OUTPUT);
 4fa:	4f ef       	ldi	r20, 0xFF	; 255
 4fc:	68 e0       	ldi	r22, 0x08	; 8
 4fe:	83 e0       	ldi	r24, 0x03	; 3
 500:	0e 94 7b 00 	call	0xf6	; 0xf6 <gpioPinDirection>
		break;
		
		default: break;
	}
}
 504:	cf 91       	pop	r28
 506:	08 95       	ret

00000508 <sevenSegEnable>:
 * Description:  enable the enable bits of the 7 segment to be able to write 
 * @param en_segment_id
 */
void sevenSegEnable(En_SevenSegId_t en_segment_id){
	
	switch(en_segment_id){
 508:	88 23       	and	r24, r24
 50a:	19 f0       	breq	.+6      	; 0x512 <sevenSegEnable+0xa>
 50c:	81 30       	cpi	r24, 0x01	; 1
 50e:	39 f0       	breq	.+14     	; 0x51e <sevenSegEnable+0x16>
 510:	08 95       	ret
		
		case SEG_0:
					gpioPinWrite(SEG_EN1_GPIO, SEG_EN1_BIT, HIGH);
 512:	4f ef       	ldi	r20, 0xFF	; 255
 514:	64 e0       	ldi	r22, 0x04	; 4
 516:	83 e0       	ldi	r24, 0x03	; 3
 518:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
					break;
 51c:	08 95       	ret
		case SEG_1:
					gpioPinWrite(SEG_EN2_GPIO, SEG_EN2_BIT, HIGH);
 51e:	4f ef       	ldi	r20, 0xFF	; 255
 520:	68 e0       	ldi	r22, 0x08	; 8
 522:	83 e0       	ldi	r24, 0x03	; 3
 524:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
 528:	08 95       	ret

0000052a <sevenSegDisable>:
 * Description: disable the enable bits of 7 segment 
 * @param en_segment_id
 */
void sevenSegDisable(En_SevenSegId_t en_segment_id){
	
		switch(en_segment_id){
 52a:	88 23       	and	r24, r24
 52c:	19 f0       	breq	.+6      	; 0x534 <sevenSegDisable+0xa>
 52e:	81 30       	cpi	r24, 0x01	; 1
 530:	39 f0       	breq	.+14     	; 0x540 <sevenSegDisable+0x16>
 532:	08 95       	ret
			
			case SEG_0:
					gpioPinWrite(SEG_EN1_GPIO, SEG_EN1_BIT, LOW);
 534:	40 e0       	ldi	r20, 0x00	; 0
 536:	64 e0       	ldi	r22, 0x04	; 4
 538:	83 e0       	ldi	r24, 0x03	; 3
 53a:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
					break;
 53e:	08 95       	ret
			case SEG_1:
					gpioPinWrite(SEG_EN2_GPIO, SEG_EN2_BIT, LOW);
 540:	40 e0       	ldi	r20, 0x00	; 0
 542:	68 e0       	ldi	r22, 0x08	; 8
 544:	83 e0       	ldi	r24, 0x03	; 3
 546:	0e 94 af 00 	call	0x15e	; 0x15e <gpioPinWrite>
 54a:	08 95       	ret

0000054c <sevenSegWrite>:

/**
 * Description: writes a digit on 7 segment 
 * @param en_segment_id, digit
 */
void sevenSegWrite(En_SevenSegId_t en_segment_id , uint8_t digit ){
 54c:	cf 93       	push	r28
 54e:	c6 2f       	mov	r28, r22
	
	switch(en_segment_id){
 550:	88 23       	and	r24, r24
 552:	19 f0       	breq	.+6      	; 0x55a <sevenSegWrite+0xe>
 554:	81 30       	cpi	r24, 0x01	; 1
 556:	59 f0       	breq	.+22     	; 0x56e <sevenSegWrite+0x22>
 558:	13 c0       	rjmp	.+38     	; 0x580 <sevenSegWrite+0x34>
		
		case SEG_0:
					gpioPortWrite(SEG_BCD_GPIO, LOW);
 55a:	60 e0       	ldi	r22, 0x00	; 0
 55c:	81 e0       	ldi	r24, 0x01	; 1
 55e:	0e 94 59 00 	call	0xb2	; 0xb2 <gpioPortWrite>
					gpioPortWrite(SEG_BCD_GPIO, 0x0F & digit);
 562:	6c 2f       	mov	r22, r28
 564:	6f 70       	andi	r22, 0x0F	; 15
 566:	81 e0       	ldi	r24, 0x01	; 1
 568:	0e 94 59 00 	call	0xb2	; 0xb2 <gpioPortWrite>
					break;
 56c:	09 c0       	rjmp	.+18     	; 0x580 <sevenSegWrite+0x34>
		case SEG_1:
					gpioPortWrite(SEG_BCD_GPIO, LOW);
 56e:	60 e0       	ldi	r22, 0x00	; 0
 570:	81 e0       	ldi	r24, 0x01	; 1
 572:	0e 94 59 00 	call	0xb2	; 0xb2 <gpioPortWrite>
					gpioPortWrite(SEG_BCD_GPIO, 0x0F & digit);
 576:	6c 2f       	mov	r22, r28
 578:	6f 70       	andi	r22, 0x0F	; 15
 57a:	81 e0       	ldi	r24, 0x01	; 1
 57c:	0e 94 59 00 	call	0xb2	; 0xb2 <gpioPortWrite>
					break;
		default: break;
	}
}
 580:	cf 91       	pop	r28
 582:	08 95       	ret

00000584 <timer0Init>:
 * @return uint8_t value
 */
uint8_t timer0Read(void){
	
	return TCNT0;
}
 584:	ef 92       	push	r14
 586:	0f 93       	push	r16
 588:	93 b7       	in	r25, 0x33	; 51
 58a:	69 2b       	or	r22, r25
 58c:	68 2b       	or	r22, r24
 58e:	63 bf       	out	0x33, r22	; 51
 590:	22 bf       	out	0x32, r18	; 50
 592:	88 30       	cpi	r24, 0x08	; 8
 594:	09 f4       	brne	.+2      	; 0x598 <timer0Init+0x14>
 596:	0c bf       	out	0x3c, r16	; 60
 598:	40 93 60 00 	sts	0x0060, r20	; 0x800060 <__data_start>
 59c:	89 b7       	in	r24, 0x39	; 57
 59e:	e8 2a       	or	r14, r24
 5a0:	e9 be       	out	0x39, r14	; 57
 5a2:	0f 91       	pop	r16
 5a4:	ef 90       	pop	r14
 5a6:	08 95       	ret

000005a8 <timer0Start>:
/**
 * Description: start the the timer 
 */
void timer0Start(void){
	
	TCCR0 |= prescaler;
 5a8:	93 b7       	in	r25, 0x33	; 51
 5aa:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 5ae:	89 2b       	or	r24, r25
 5b0:	83 bf       	out	0x33, r24	; 51
 5b2:	08 95       	ret

000005b4 <timer0Stop>:
 * Description: stop the timer 
 */
void timer0Stop(void){
	/* clear the first three bits to provide no clock to the timer */
	
		TCCR0 &= T0_NO_CLOCK;
 5b4:	83 b7       	in	r24, 0x33	; 51
 5b6:	88 7f       	andi	r24, 0xF8	; 248
 5b8:	83 bf       	out	0x33, r24	; 51
 5ba:	08 95       	ret

000005bc <timer0DelayMs>:

/**
 * Description: 
 * @param delay
 */
void timer0DelayMs(uint16_t u16_delay_in_ms){
 5bc:	cf 93       	push	r28
 5be:	df 93       	push	r29
 5c0:	ec 01       	movw	r28, r24
			//uint16_t overflows;
			//clockCycleTime =    prescaler / FREQUENCY;
			//ticksNeeded =  u16_delay_in_ms  / clockCycleTime;
			//overflows =  u16_delay_in_ms * FREQUENCY / (1000 * 255 *prescaler);
		
		timer0Start();
 5c2:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <timer0Start>
		while(u16_delay_in_ms--){
 5c6:	9e 01       	movw	r18, r28
 5c8:	21 50       	subi	r18, 0x01	; 1
 5ca:	31 09       	sbc	r19, r1
 5cc:	cd 2b       	or	r28, r29
 5ce:	59 f0       	breq	.+22     	; 0x5e6 <timer0DelayMs+0x2a>
 * Description: set the value of timer/counter register 
 * @param value 
 */
void timer0Set(uint8_t u8_value){
	
	TCNT0 = u8_value;
 5d0:	96 e0       	ldi	r25, 0x06	; 6
 5d2:	92 bf       	out	0x32, r25	; 50
		
		timer0Start();
		while(u16_delay_in_ms--){
			
			timer0Set(6); // Preload with 256 - 250 counts
			while(!(TIFR & (1 << 0)));
 5d4:	08 b6       	in	r0, 0x38	; 56
 5d6:	00 fe       	sbrs	r0, 0
 5d8:	fd cf       	rjmp	.-6      	; 0x5d4 <timer0DelayMs+0x18>
			TIFR |= (1 << 0); // clear with writing one 
 5da:	88 b7       	in	r24, 0x38	; 56
 5dc:	81 60       	ori	r24, 0x01	; 1
 5de:	88 bf       	out	0x38, r24	; 56
			//clockCycleTime =    prescaler / FREQUENCY;
			//ticksNeeded =  u16_delay_in_ms  / clockCycleTime;
			//overflows =  u16_delay_in_ms * FREQUENCY / (1000 * 255 *prescaler);
		
		timer0Start();
		while(u16_delay_in_ms--){
 5e0:	21 50       	subi	r18, 0x01	; 1
 5e2:	31 09       	sbc	r19, r1
 5e4:	b0 f7       	brcc	.-20     	; 0x5d2 <timer0DelayMs+0x16>
			
			timer0Set(6); // Preload with 256 - 250 counts
			while(!(TIFR & (1 << 0)));
			TIFR |= (1 << 0); // clear with writing one 
		}
		timer0Stop();
 5e6:	0e 94 da 02 	call	0x5b4	; 0x5b4 <timer0Stop>
}
 5ea:	df 91       	pop	r29
 5ec:	cf 91       	pop	r28
 5ee:	08 95       	ret

000005f0 <_exit>:
 5f0:	f8 94       	cli

000005f2 <__stop_program>:
 5f2:	ff cf       	rjmp	.-2      	; 0x5f2 <__stop_program>
